<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/lindsay/xeolabs/xeogl-next/xeogl/examples/js/models/XML3DModel.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">

    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
            
                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
            
                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
            
                <li><a href="../classes/Annotation.html">Annotation</a></li>
            
                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
            
                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
            
                <li><a href="../classes/BIMServerModel.html">BIMServerModel</a></li>
            
                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
            
                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
            
                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
            
                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
            
                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
            
                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/Clip.html">Clip</a></li>
            
                <li><a href="../classes/ClipControl.html">ClipControl</a></li>
            
                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
            
                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
            
                <li><a href="../classes/Curve.html">Curve</a></li>
            
                <li><a href="../classes/CustomProjection.html">CustomProjection</a></li>
            
                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
            
                <li><a href="../classes/DirLight.html">DirLight</a></li>
            
                <li><a href="../classes/EdgeMaterial.html">EdgeMaterial</a></li>
            
                <li><a href="../classes/EmphasisMaterial.html">EmphasisMaterial</a></li>
            
                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
            
                <li><a href="../classes/Frustum.html">Frustum</a></li>
            
                <li><a href="../classes/Geometry.html">Geometry</a></li>
            
                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
            
                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/LambertMaterial.html">LambertMaterial</a></li>
            
                <li><a href="../classes/LightMap.html">LightMap</a></li>
            
                <li><a href="../classes/Material.html">Material</a></li>
            
                <li><a href="../classes/Mesh.html">Mesh</a></li>
            
                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
            
                <li><a href="../classes/Model.html">Model</a></li>
            
                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
            
                <li><a href="../classes/Ortho.html">Ortho</a></li>
            
                <li><a href="../classes/OutlineMaterial.html">OutlineMaterial</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
            
                <li><a href="../classes/Perspective.html">Perspective</a></li>
            
                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
            
                <li><a href="../classes/Pin.html">Pin</a></li>
            
                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
            
                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
            
                <li><a href="../classes/PointLight.html">PointLight</a></li>
            
                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
            
                <li><a href="../classes/ReflectionMap.html">ReflectionMap</a></li>
            
                <li><a href="../classes/Scene.html">Scene</a></li>
            
                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
            
                <li><a href="../classes/Shadow.html">Shadow</a></li>
            
                <li><a href="../classes/Skybox.html">Skybox</a></li>
            
                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
            
                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
            
                <li><a href="../classes/Spinner.html">Spinner</a></li>
            
                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
            
                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
            
                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
            
                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
            
                <li><a href="../classes/STLModel.html">STLModel</a></li>
            
                <li><a href="../classes/Story.html">Story</a></li>
            
                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
            
                <li><a href="../classes/TestModel.html">TestModel</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
            
                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
            
                <li><a href="../classes/Viewport.html">Viewport</a></li>
            
                <li><a href="../classes/xeogl.xeogl.html">xeogl.xeogl</a></li>
            
                <li><a href="../classes/XML3DModel.html">XML3DModel</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..//modules/animation.html">animation</a></li>
            
                <li><a href="..//modules/annotations.html">annotations</a></li>
            
                <li><a href="..//modules/camera.html">camera</a></li>
            
                <li><a href="..//modules/canvas.html">canvas</a></li>
            
                <li><a href="..//modules/clipping.html">clipping</a></li>
            
                <li><a href="..//modules/controls.html">controls</a></li>
            
                <li><a href="..//modules/curves.html">curves</a></li>
            
                <li><a href="..//modules/effects.html">effects</a></li>
            
                <li><a href="..//modules/generation.html">generation</a></li>
            
                <li><a href="..//modules/geometry.html">geometry</a></li>
            
                <li><a href="..//modules/helpers.html">helpers</a></li>
            
                <li><a href="..//modules/input.html">input</a></li>
            
                <li><a href="..//modules/lighting.html">lighting</a></li>
            
                <li><a href="..//modules/materials.html">materials</a></li>
            
                <li><a href="..//modules/math.html">math</a></li>
            
                <li><a href="..//modules/meshes.html">meshes</a></li>
            
                <li><a href="..//modules/models.html">models</a></li>
            
                <li><a href="..//modules/objects.html">objects</a></li>
            
                <li><a href="..//modules/rendering.html">rendering</a></li>
            
                <li><a href="..//modules/scene.html">scene</a></li>
            
                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
            
                <li><a href="..//modules/stories.html">stories</a></li>
            
                <li><a href="..//modules/xeogl.html">xeogl</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
        <!--Show:-->
        <!--<label for="api-show-inherited">-->
            <!--<input type="checkbox" id="api-show-inherited" checked>-->
            <!--Inherited-->
        <!--</label>-->

        <!--<label for="api-show-protected">-->
            <!--<input type="checkbox" id="api-show-protected">-->
            <!--Protected-->
        <!--</label>-->

        <!--<label for="api-show-private">-->
            <!--<input type="checkbox" id="api-show-private">-->
            <!--Private-->
        <!--</label>-->
        <!--<label for="api-show-deprecated">-->
            <!--<input type="checkbox" id="api-show-deprecated">-->
            <!--Deprecated-->
        <!--</label>-->

    <!--</div>-->


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/lindsay/xeolabs/xeogl-next/xeogl/examples/js/models/XML3DModel.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 A **XML3DModel** is a {{#crossLink &quot;Model&quot;}}{{/crossLink}} loaded from a &lt;a href=&quot;https://en.wikipedia.org/wiki/3DXML&quot; target = &quot;_other&quot;&gt;3DXML&lt;/a&gt; file.

 @class XML3DModel
 @module xeogl
 @submodule models
 @constructor
 @param [scene] {Scene} Parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} - creates this XML3DModel in the default
 {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this XML3D.
 @param [cfg.src] {String} Path to a 3DXML file. You can set this to a new file path at any time.
 @param [cfg.displayEffect] {String} Display effect to render with: &quot;shadedWithEdges&quot; | &quot;shaded&quot; | &quot;hiddenLinesRemoved&quot; | &quot;hiddenLinesVisible&quot; | &quot;wireframe&quot;.
 @extends Model
 */
(function () {

    &quot;use strict&quot;;

    xeogl.XML3DModel = xeogl.Model.extend({

        type: &quot;xeogl.XML3DModel&quot;,

        _init: function (cfg) {
            this._super(cfg);

            /**
             * Supported 3DXML schema versions
             * @property supportedSchemas
             * @type {string[]}
             */
            this.supportedSchemas = [&quot;4.2&quot;];

            this._defaultMaterial = new xeogl.MetallicMaterial(this, {
                baseColor: [1, 1, 1],
                metallic: 0.6,
                roughness: 0.6
            });

            // Material shared by all Meshes that have &quot;lines&quot; Geometry
            // Overrides whatever material 3DXML would apply.
            this._wireframeMaterial = new xeogl.LambertMaterial(this, {
                color: [0, 0, 0],
                lineWidth: 2
            });

            // EmphasisMaterial used to create solid, hidden-line effect when rendering solid wireframe
            this._wireframeGhostMaterial = new xeogl.EmphasisMaterial(this, {
                fill: true,
                fillColor: [1, 1, 1],
                fillAlpha: .8,
                //edges: false,
                edges: true,
                vertices: false
            });

            this._src = null;
            this._options = cfg;

            /**
             * Default viewpoint, containing eye, look and up vectors.
             * Only defined if found in the 3DXML file.
             * @property viewpoint
             * @type {Float32Array}
             */
            this.viewpoint = null;

            this.src = cfg.src;
            this.displayEffect = cfg.displayEffect;
        },

        _props: {

            /**
             Path to a 3DXML file.

             You can set this to a new file path at any time (except while loading), which will cause the XML3D to load components from
             the new file (after first destroying any components loaded from a previous file path).

             Fires a {{#crossLink &quot;XML3D/loaded:event&quot;}}{{/crossLink}} event when the 3DXML has loaded.

             @property src
             @type String
             */
            src: {
                set: function (value) {
                    if (!value) {
                        return;
                    }
                    if (!xeogl._isString(value)) {
                        this.error(&quot;Value for &#x27;src&#x27; should be a string&quot;);
                        return;
                    }
                    if (value === this._src) { // Already loaded this XML3D

                        /**
                         Fired whenever this XML3D has finished loading components from the 3DXML file
                         specified by {{#crossLink &quot;XML3D/src:property&quot;}}{{/crossLink}}.
                         @event loaded
                         */
                        this.fire(&quot;loaded&quot;, true, true);
                        return;
                    }
                    this.destroyAll();
                    this._src = value;
                    xeogl.XML3DModel.load(this, this._src, this._options); // Don&#x27;t need completion callbacks (model fires &quot;loaded&quot; or &quot;error&quot;)
                },
                get: function () {
                    return this._src;
                }
            },

            /**
             Display effect to render with: &quot;shadedWithEdges&quot; | &quot;shaded&quot; | &quot;hiddenLinesRemoved&quot; | &quot;hiddenLinesVisible&quot; | &quot;wireframe&quot;.

             @property displayEffect
             @default &quot;shadedWithEdges&quot;
             @type String
             */
            displayEffect: {
                set: function (displayEffect) {
                    displayEffect = displayEffect || &quot;shadedWithEdges&quot;;
                    if (this._displayEffect === displayEffect) {
                        return;
                    }
                    this._displayEffect = displayEffect;
                    var meshes = this.types[&quot;xeogl.Mesh&quot;];
                    if (meshes) {
                        switch (this._displayEffect) {
                            case &quot;shadedWithEdges&quot;:
                                this._wireframeMaterial.lineWidth = 2;
                                for (var id in meshes) {
                                    var mesh = meshes[id];
                                    if (mesh.geometry.primitive !== &quot;lines&quot;) {
                                        mesh.visible = true;
                                        mesh.ghosted = false;
                                        mesh.ghostMaterial.fillAlpha = 0.5;
                                        mesh.opacity = 1;
                                    } else {
                                        mesh.visible = true; // Show lines
                                    }
                                }
                                break;
                            case &quot;shaded&quot;:
                                this._wireframeMaterial.lineWidth = 2;
                                for (var id in meshes) {
                                    var mesh = meshes[id];
                                    if (mesh.geometry.primitive !== &quot;lines&quot;) {
                                        mesh.visible = true;
                                        mesh.ghosted = false;
                                        mesh.ghostMaterial.fillAlpha = 0.5;
                                        mesh.opacity = 1;
                                    } else {
                                        mesh.visible = false;  // Hide lines
                                    }
                                }
                                break;
                            case &quot;hiddenLinesRemoved&quot;:
                                this._wireframeMaterial.lineWidth = 2;
                                for (var id in meshes) {
                                    var mesh = meshes[id];
                                    if (mesh.geometry.primitive !== &quot;lines&quot;) {
                                        mesh.visible = true;
                                        mesh.ghosted = true;
                                        mesh.ghostMaterial.fillAlpha = 1.0;
                                        mesh.opacity = 1.0;
                                    } else {
                                        mesh.visible = true;  // Show lines
                                    }
                                }
                                break;
                            case &quot;hiddenLinesVisible&quot;:
                                this._wireframeMaterial.lineWidth = 1;
                                for (var id in meshes) {
                                    var mesh = meshes[id];
                                    if (mesh.geometry.primitive !== &quot;lines&quot;) {
                                        mesh.visible = true;
                                        mesh.ghosted = false;
                                        mesh.ghostMaterial.fillAlpha = 0.5;
                                        mesh.opacity = 0.5;
                                    } else {
                                        mesh.visible = true;  // Show lines
                                    }
                                }
                                break;
                            case &quot;wireframe&quot;:
                                this._wireframeMaterial.lineWidth = 1;
                                for (var id in meshes) {
                                    var mesh = meshes[id];
                                    if (mesh.geometry.primitive !== &quot;lines&quot;) {
                                        mesh.visible = false;
                                        mesh.ghosted = false;
                                        mesh.ghostMaterial.fillAlpha = 0.5;
                                        mesh.opacity = 0.5;
                                    } else {
                                        mesh.visible = true;  // Show lines
                                    }
                                }
                                break;
                        }
                    }
                },
                get: function () {
                    return this._displayEffect;
                }
            }
        },

        _destroy: function () {
            this.destroyAll();
        }
    });

    /**
     * Loads 3DXML from a URL into a {{#crossLink &quot;Model&quot;}}{{/crossLink}}.
     *
     * @method load
     * @static
     * @param {Model} model Model to load into.
     * @param {String} src Path to 3DXML file.
     * @param {Object} options Loading options.
     * @param {Function} [ok] Completion callback.
     * @param {Function} [error] Error callback.
     */
    xeogl.XML3DModel.load = function (model, src, options, ok, error) {

        var spinner = model.scene.canvas.spinner;
        spinner.processes++;

        load3DXML(model, src, options, function () {
                spinner.processes--;
                xeogl.scheduleTask(function () {
                    //console.log(&quot;3DXML loaded.&quot;);
                    model.fire(&quot;loaded&quot;, true, true);
                });
                if (ok) {
                    ok();
                }
            },
            function (msg) {
                spinner.processes--;
                model.error(msg);
                if (error) {
                    error(msg);
                }
                /**
                 Fired whenever this XML3D fails to load the 3DXML file
                 specified by {{#crossLink &quot;XML3D/src:property&quot;}}{{/crossLink}}.
                 @event error
                 @param msg {String} Description of the error
                 */
                model.fire(&quot;error&quot;, msg);
            },
            function (err) {
                console.log(&quot;Error, Will Robinson: &quot; + err);
            });
    };

    var load3DXML = (function () {
        return function (model, src, options, ok, error) {
            loadZIP(src, function (zip) { // OK
                    parse3DXML(zip, options, model, ok, error);
                },
                error);
        };
    })();

    var parse3DXML = (function () {

        return function (zip, options, model, ok) {
            var ctx = {
                zip: zip,
                edgeThreshold: options.edgeThreshold || 20,
                materialWorkflow: options.materialWorkflow,
                scene: model.scene,
                model: model,
                info: {
                    references: {}
                },
                materials: {}
            };
            model.scene.loading++; // Disables (re)compilation


            // Now parse 3DXML

            parseDocument(ctx, function () {
                model.scene.loading--; // Re-enables (re)compilation
                //console.log(&quot;3DXML parsed.&quot;);
                ok();
            });
        };

        function parseDocument(ctx, ok) {
            ctx.zip.getFile(&quot;Manifest.xml&quot;, function (xmlDoc, json) {
                var node = json;
                var children = node.children;
                for (var i = 0, len = children.length; i &lt; len; i++) {
                    var child = children[i];
                    switch (child.type) {
                        case &quot;Manifest&quot;:
                            parseManifest(ctx, child, ok);
                            break;
                    }
                }
            });
        }

        function parseManifest(ctx, manifest, ok) {
            var children = manifest.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Root&quot;:
                        var rootFileSrc = child.children[0];
                        ctx.zip.getFile(rootFileSrc, function (xmlDoc, json) {
                            parseRoot(ctx, json, ok);
                        });
                        break;
                }
            }
        }

        function parseRoot(ctx, node, ok) {
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Model_3dxml&quot;:
                        parseModel(ctx, child, ok);
                        break;
                }
            }
        }

        function parseModel(ctx, node, ok) {
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Header&quot;:
                        parseHeader(ctx, child);
                        break;
                    case &quot;ProductStructure&quot;:
                        parseProductStructure(ctx, child, ok);
                        break;
                    case &quot;DefaultView&quot;:
                        parseDefaultView(ctx, child);
                        break;
                }
            }
        }

        function parseHeader(ctx, node) {
            var children = node.children;
            var metaData = {};
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;SchemaVersion&quot;:
                        metaData.schemaVersion = child.children[0];
                        if (!isSchemaVersionSupported(ctx, metaData.schemaVersion)) {
                            ctx.model.error(&quot;Schema version not supported: &quot; + metaData.schemaVersion + &quot; - supported versions are: &quot; + ctx.model.supportedSchemas.join(&quot;,&quot;));
                        } else {
                            //ctx.model.log(&quot;Parsing schema version: &quot; + metaData.schemaVersion);
                        }
                        break;
                    case &quot;Title&quot;:
                        metaData.title = child.children[0];
                        break;
                    case &quot;Author&quot;:
                        metaData.author = child.children[0];
                        break;
                    case &quot;Created&quot;:
                        metaData.created = child.children[0];
                        break;
                }
            }
            ctx.model.meta = metaData;
        }

        function isSchemaVersionSupported(ctx, schemaVersion) {
            var supportedSchemas = ctx.model.supportedSchemas;
            for (var i = 0, len = supportedSchemas.length; i &lt; len; i++) {
                if (schemaVersion === supportedSchemas[i]) {
                    return true;
                }
            }
            return false;
        }

        function parseProductStructure(ctx, productStructureNode, ok) {

            parseReferenceReps(ctx, productStructureNode, function (referenceReps) {

                //----------------------------------------------------------------------------------
                // Parse out an intermediate scene DAG representation, that we can then
                // recursive descend through to build a xeogl Object hierarchy.
                //----------------------------------------------------------------------------------

                var children = productStructureNode.children;

                var reference3Ds = {};
                var instanceReps = {};
                var instance3Ds = {};

                var rootNode;
                var nodes = {};

                // Map all the elements

                for (var i = 0, len = children.length; i &lt; len; i++) {
                    var child = children[i];
                    switch (child.type) {

                        case &quot;Reference3D&quot;:
                            reference3Ds[child.id] = {
                                type: &quot;Reference3D&quot;,
                                id: child.id,
                                name: child.name,
                                instance3Ds: {},
                                instanceReps: {}
                            };
                            break;

                        case &quot;InstanceRep&quot;:
                            var isAggregatedBy;
                            var isInstanceOf;
                            var relativeMatrix;
                            for (var j = 0, lenj = child.children.length; j &lt; lenj; j++) {
                                var child2 = child.children[j];
                                switch (child2.type) {
                                    case &quot;IsAggregatedBy&quot;:
                                        isAggregatedBy = child2.children[0];
                                        break;
                                    case &quot;IsInstanceOf&quot;:
                                        isInstanceOf = child2.children[0];
                                        break;
                                }
                            }
                            instanceReps[child.id] = {
                                type: &quot;InstanceRep&quot;,
                                id: child.id,
                                isAggregatedBy: isAggregatedBy,
                                isInstanceOf: isInstanceOf,
                                referenceReps: {}
                            };
                            break;

                        case &quot;Instance3D&quot;:
                            var isAggregatedBy;
                            var isInstanceOf;
                            var relativeMatrix;
                            for (var j = 0, lenj = child.children.length; j &lt; lenj; j++) {
                                var child2 = child.children[j];
                                switch (child2.type) {
                                    case &quot;IsAggregatedBy&quot;:
                                        isAggregatedBy = child2.children[0];
                                        break;
                                    case &quot;IsInstanceOf&quot;:
                                        isInstanceOf = child2.children[0];
                                        break;
                                    case &quot;RelativeMatrix&quot;:
                                        relativeMatrix = child2.children[0];
                                        break;
                                }
                            }
                            instance3Ds[child.id] = {
                                type: &quot;Instance3D&quot;,
                                id: child.id,
                                isAggregatedBy: isAggregatedBy,
                                isInstanceOf: isInstanceOf,
                                relativeMatrix: relativeMatrix,
                                reference3Ds: {}
                            };
                            break;
                    }
                }

                // Connect Reference3Ds to the Instance3Ds they aggregate

                for (var id in instance3Ds) {
                    var instance3D = instance3Ds[id];
                    var reference3D = reference3Ds[instance3D.isAggregatedBy];
                    if (reference3D) {
                        reference3D.instance3Ds[instance3D.id] = instance3D;
                    } else {
                        alert(&quot;foo&quot;)
                    }
                }

                // Connect Instance3Ds to the Reference3Ds they instantiate

                for (var id in instance3Ds) {
                    var instance3D = instance3Ds[id];
                    var reference3D = reference3Ds[instance3D.isInstanceOf];
                    instance3D.reference3Ds[reference3D.id] = reference3D;
                    reference3D.instance3D = instance3D;
                }

                // Connect InstanceReps to the ReferenceReps they instantiate

                for (var id in instanceReps) {
                    var instanceRep = instanceReps[id];
                    var referenceRep = referenceReps[instanceRep.isInstanceOf];
                    if (referenceRep) {
                        instanceRep.referenceReps[referenceRep.id] = referenceRep;
                    }
                }

                // Connect Reference3Ds to the InstanceReps they aggregate

                for (var id in instanceReps) {
                    var instanceRep = instanceReps[id];
                    var reference3D = reference3Ds[instanceRep.isAggregatedBy];
                    if (reference3D) {
                        reference3D.instanceReps[instanceRep.id] = instanceRep;
                    }
                }

                // console.log(&quot;*****************************************************************************&quot;);
                // console.log(&quot;reference3Ds:\n\n&quot;);
                // console.log(JSON.stringify(reference3Ds, null, &quot;\t&quot;));
                // console.log(&quot;*****************************************************************************&quot;);

                function parseReference3D(ctx, reference3D, group) {
                    //ctx.model.log(&quot;parseReference3D( &quot; + reference3D.id + &quot; )&quot;);
                    for (var id in reference3D.instance3Ds) {
                        parseInstance3D(ctx, reference3D.instance3Ds[id], group);
                    }
                    for (var id in reference3D.instanceReps) {
                        parseInstanceRep(ctx, reference3D.instanceReps[id], group);
                    }
                }

                function parseInstance3D(ctx, instance3D, group) {
                    //ctx.model.log(&quot;parseInstance3D( &quot; + instance3D.id + &quot; )&quot;);

                    if (instance3D.relativeMatrix) {
                        var matrix = parseFloatArray(instance3D.relativeMatrix, 12);
                        var translate = [matrix[9], matrix[10], matrix[11]];
                        var mat3 = matrix.slice(0, 9); // Rotation matrix
                        var mat4 = xeogl.math.mat3ToMat4(mat3, xeogl.math.identityMat4()); // Convert rotation matrix to 4x4
                        var childGroup = new xeogl.Group(ctx.model.scene, {
                            position: translate
                        });
                        if (group) {
                            group.addChild(childGroup);
                        } else {
                            ctx.model.addChild(childGroup);
                        }
                        group = childGroup;
                        childGroup = new xeogl.Group(ctx.model.scene, {
                            matrix: mat4
                        });
                        group.addChild(childGroup);
                        group = childGroup;
                    } else {
                        var childGroup = new xeogl.Group(ctx.model.scene, {});
                        if (group) {
                            group.addChild(childGroup);
                        } else {
                            ctx.model.addChild(childGroup);
                        }
                        group = childGroup;
                    }
                    for (var id in instance3D.reference3Ds) {
                        parseReference3D(ctx, instance3D.reference3Ds[id], group);
                    }
                }

                function parseInstanceRep(ctx, instanceRep, group) {
                    //ctx.model.log(&quot;parseInstanceRep( &quot; + instanceRep.id + &quot; )&quot;);
                    if (instanceRep.referenceReps) {
                        for (var id in instanceRep.referenceReps) {
                            var referenceRep = instanceRep.referenceReps[id];
                            for (var id2 in referenceRep) {
                                if (id2 === &quot;id&quot;) {
                                    continue; // HACK
                                }
                                var meshCfg = referenceRep[id2];
                                var lines = meshCfg.geometry.primitive === &quot;lines&quot;;
                                var material = lines ? ctx.model._wireframeMaterial : (meshCfg.materialId ? ctx.materials[meshCfg.materialId] : null);
                                var colorize = meshCfg.color;
                                var mesh = new xeogl.Mesh(ctx.model.scene, {
                                    geometry: meshCfg.geometry,
                                    material: material || ctx.model._defaultMaterial,
                                    colorize: colorize,
                                    ghostMaterial: !lines ? ctx.model._wireframeGhostMaterial : null,
                                    backfaces: false,
                                    quantized: true
                                });
                                ctx.model._addComponent(mesh);
                                if (group) {
                                    group.addChild(mesh);
                                } else {
                                    ctx.model.addChild(mesh);
                                }
                                mesh.colorize = colorize; // HACK: Mesh has inherited model&#x27;s colorize state, so we need to restore it (we&#x27;d better not modify colorize on the model).
                            }
                        }
                    }
                }

                // Find the root Reference3D

                for (var id in reference3Ds) {
                    var reference3D = reference3Ds[id];
                    if (!reference3D.instance3D) {
                        parseReference3D(ctx, reference3D, null); // HACK: Assuming that root has id == &quot;1&quot;
                        ok();
                        return;
                    }
                }

                alert(&quot;No root Reference3D element found in this model - can&#x27;t load.&quot;);

                ok();
            });
        }

        function parseIntArray(str) {
            var parts = str.split(&quot; &quot;);
            var result = new Int32Array(parts.length);
            for (var i = 0; i &lt; parts.length; i++) {
                result[i] = parseInt(parts[i]);
            }
            return result;
        }

        function parseReferenceReps(ctx, node, ok) {
            var referenceReps = {};
            var children = node.children;
            var numToLoad = 0;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                if (child.type === &quot;ReferenceRep&quot;) {
                    numToLoad++;
                }
            }
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;ReferenceRep&quot;:
                        if (child.associatedFile) {
                            var src = stripURN(child.associatedFile);
                            (function () {
                                var childId = child.id;
                                ctx.zip.getFile(src, function (xmlDoc, json) {

                                        var materialIds = xmlDoc.getElementsByTagName(&quot;MaterialId&quot;);

                                        loadCATMaterialRefDocuments(ctx, materialIds, function () {

                                            // ctx.model.log(&quot;reference loaded: &quot; + src);
                                            var referenceRep = {
                                                id: childId
                                            };
                                            parse3DRepDocument(ctx, json, referenceRep);
                                            referenceReps[childId] = referenceRep;
                                            if (--numToLoad === 0) {
                                                console.log(&quot;All ReferenceReps loaded.&quot;);
                                                ok(referenceReps);
                                            }
                                        });
                                    },
                                    function (error) {
                                        // TODO:
                                    });
                            })();
                        }
                        break;
                }
            }
        }


        function parseDefaultView(ctx, node) {
            // ctx.model.log(&quot;parseDefaultView&quot;);
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Viewpoint&quot;:
                        var children2 = child.children;
                        ctx.model.viewpoint = {};
                        for (var i2 = 0, len2 = children2.length; i2 &lt; len2; i2++) {
                            var child2 = children2[i];
                            switch (child2.type) {
                                case &quot;Position&quot;:
                                    ctx.model.viewpoint.eye = parseFloatArray(child2.children[0], 3);
                                    break;
                                case &quot;Sight&quot;:
                                    ctx.model.viewpoint.look = parseFloatArray(child2.children[0], 3);
                                    break;
                                case &quot;Up&quot;:
                                    ctx.model.viewpoint.up = parseFloatArray(child2.children[0], 3);
                                    break;
                            }
                        }
                        break;
                    case &quot;DefaultViewProperty&quot;:
                        break;
                }
            }
        }

        function parse3DRepDocument(ctx, node, result) {
            // ctx.model.log(&quot;parse3DRepDocument&quot;);
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;XMLRepresentation&quot;:
                        parseXMLRepresentation(ctx, child, result);
                        break;
                }
            }
        }

        function parseXMLRepresentation(ctx, node, result) {
            // ctx.model.log(&quot;parseXMLRepresentation&quot;);
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Root&quot;:
                        parse3DRepRoot(ctx, child, result);
                        break;
                }
            }
        }

        function parse3DRepRoot(ctx, node, result) {
            // ctx.model.log(&quot;parse3DRepRoot&quot;);
            switch (node[&quot;xsi:type&quot;]) {
                case &quot;BagRepType&quot;:
                    break;
                case &quot;PolygonalRepType&quot;:
                    break;
            }
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Rep&quot;:
                        parse3DRepRep(ctx, child, result);
                        break;
                }
            }
        }

        function parse3DRepRep(ctx, node, result) {
            // ctx.model.log(&quot;parse3DRep&quot;);
            switch (node[&quot;xsi:type&quot;]) {
                case &quot;BagRepType&quot;:
                    break;
                case &quot;PolygonalRepType&quot;:
                    break;
            }
            var meshesResult = {
                edgeThreshold: ctx.edgeThreshold || 20
            };
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Rep&quot;:
                        parse3DRepRep(ctx, child, result);
                        break;
                    case &quot;Edges&quot;:
                        meshesResult.primitive = &quot;lines&quot;;
                        parseEdges(ctx, child, meshesResult);
                        break;
                    case &quot;Faces&quot;:
                        meshesResult.primitive = &quot;triangles&quot;;
                        parseFaces(ctx, child, meshesResult);
                        break;
                    case &quot;VertexBuffer&quot;:
                        parseVertexBuffer(ctx, child, meshesResult);
                        break;
                    case &quot;SurfaceAttributes&quot;:
                        parseSurfaceAttributes(ctx, child, meshesResult);
                        break;
                }
            }
            if (meshesResult.positions) {
                var geometry = new xeogl.Geometry(ctx.model.scene, meshesResult);
                ctx.model._addComponent(geometry);
                result[geometry.id] = {
                    geometry: geometry,
                    color: meshesResult.color || [1.0, 1.0, 1.0, 1.0],
                    materialId: meshesResult.materialId
                };
            }
        }

        function parseEdges(ctx, node, result) {
            // ctx.model.log(&quot;parseEdges&quot;);
            result.positions = [];
            result.indices = [];
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Polyline&quot;:
                        parsePolyline(ctx, child, result);
                        break;
                }
            }
        }

        function parsePolyline(ctx, node, result) {
            //ctx.model.log(&quot;parsePolyline&quot;);
            var vertices = node.vertices;
            if (vertices) {
                var positions = parseFloatArray(vertices, 3);
                if (positions.length &gt; 0) {
                    var positionsOffset = result.positions.length / 3;
                    for (var i = 0, len = positions.length; i &lt; len; i++) {
                        result.positions.push(positions[i]);
                    }
                    for (var i = 0, len = (positions.length / 3) - 1; i &lt; len; i++) {
                        result.indices.push(positionsOffset + i);
                        result.indices.push(positionsOffset + i + 1);
                    }
                }
            }
        }

        function parseFaces(ctx, node, result) {
            // ctx.model.log(&quot;parseFaces&quot;);
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Face&quot;:
                        parseFace(ctx, child, result);
                        break;
                }
            }
        }

        function parseFace(ctx, node, result) {
            // ctx.model.log(&quot;parseFace&quot;);

            var strips = node.strips;
            if (strips) {

                // Triangle strips

                var arrays = parseIntArrays(strips);
                if (arrays.length &gt; 0) {
                    result.primitive = &quot;triangles&quot;;
                    var indices = [];
                    for (var i = 0, len = arrays.length; i &lt; len; i++) {
                        var array = convertTriangleStrip(arrays[i]);
                        for (var j = 0, lenj = array.length; j &lt; lenj; j++) {
                            indices.push(array[j]);
                        }
                    }
                    result.indices = indices; // TODO
                }
            } else {

                // Triangle meshes

                var triangles = node.triangles;
                if (triangles) {
                    result.primitive = &quot;triangles&quot;;
                    result.indices = parseIntArray(triangles);
                }
            }

            // Material

            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;SurfaceAttributes&quot;:
                        parseSurfaceAttributes(ctx, child, result);
                        break;
                }
            }
        }

        function convertTriangleStrip(indices) {
            var ccw = false;
            var indices2 = [];
            for (var i = 0, len = indices.length; i &lt; len - 2; i++) {
                if (ccw) {
                    if (i &amp; 1) { //
                        indices2.push(indices[i]);
                        indices2.push(indices[i + 1]);
                        indices2.push(indices[i + 2]);
                    } else {
                        indices2.push(indices[i]);
                        indices2.push(indices[i + 2]);
                        indices2.push(indices[i + 1]);
                    }
                } else {
                    if (i &amp; 1) { //
                        indices2.push(indices[i]);
                        indices2.push(indices[i + 2]);
                        indices2.push(indices[i + 1]);
                    } else {
                        indices2.push(indices[i]);
                        indices2.push(indices[i + 1]);
                        indices2.push(indices[i + 2]);
                    }
                }
            }
            return indices2;
        }

        function parseVertexBuffer(ctx, node, result) {
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Positions&quot;:
                        result.positions = parseFloatArray(child.children[0], 3);
                        break;
                    case &quot;Normals&quot;:
                        result.normals = parseFloatArray(child.children[0], 3);
                        break;
                    case &quot;TextureCoordinates&quot;: // TODO: Support dimension and channel?
                        result.uv = parseFloatArray(child.children[0], 2);
                        break;
                }
            }
        }

        function parseIntArrays(str) {
            var coordStrings = str.split(&quot;,&quot;);
            var array = [];
            for (var i = 0, len = coordStrings.length; i &lt; len; i++) {
                var coordStr = coordStrings[i].trim();
                if (coordStr.length &gt; 0) {
                    var elemStrings = coordStr.split(&quot; &quot;);
                    var arr = new Int16Array(elemStrings.length);
                    var arrIdx = 0;
                    for (var j = 0, lenj = elemStrings.length; j &lt; lenj; j++) {
                        if (elemStrings[j] !== &quot;&quot;) {
                            arr[arrIdx++] = parseInt(elemStrings[j]);
                        }
                    }
                    array.push(arr);
                }
            }
            return array;
        }

        function parseFloatArray(str, numElems) {
            str = str.split(&quot;,&quot;);
            var arr = new Float32Array(str.length * numElems);
            var arrIdx = 0;
            for (var i = 0, len = str.length; i &lt; len; i++) {
                var value = str[i];
                value = value.split(&quot; &quot;);
                for (var j = 0, lenj = value.length; j &lt; lenj; j++) {
                    if (value[j] !== &quot;&quot;) {
                        arr[arrIdx++] = parseFloat(value[j]);
                    }
                }
            }
            return arr;
        }

        function parseIntArray(str) {
            str = str.split(&quot; &quot;);
            var arr = new Int32Array(str.length);
            var arrIdx = 0;
            for (var i = 0, len = str.length; i &lt; len; i++) {
                var value = str[i];
                arr[i] = parseInt(value);
            }
            return arr;
        }

        function parseSurfaceAttributes(ctx, node, result) {
            result.color = [1, 1, 1, 1];
            var children = node.children;
            for (var i = 0, len = children.length; i &lt; len; i++) {
                var child = children[i];
                switch (child.type) {
                    case &quot;Color&quot;:
                        result.color[0] = child.red;
                        result.color[1] = child.green;
                        result.color[2] = child.blue;
                        result.color[3] = child.alpha;
                        break;
                    case &quot;MaterialApplication&quot;:
                        var children2 = child.children;
                        for (var j = 0, lenj = children2.length; j &lt; lenj; j++) {
                            var child2 = children2[j];
                            switch (child2.type) {
                                case &quot;MaterialId&quot;:
                                    var materialId = getIDFromURI(child2.id);
                                    var material = ctx.materials[materialId];
                                    if (!material) {
                                        ctx.model.error(&quot;material  not found: &quot; + materialId);
                                    }
                                    result.materialId = materialId;
                                    break;
                            }
                        }
                        break;
                }
            }
        }
    })();

    //----------------------------------------------------------------------------------------------------
    // Materials
    //----------------------------------------------------------------------------------------------------

    function loadCATMaterialRefDocuments(ctx, materialIds, ok) {
        var loaded = {};

        function load(i, done) {
            if (i &gt;= materialIds.length) {
                ok();
                return;
            }
            var materialId = materialIds[i];
            var src = materialId.id;
            var colonIdx = src.lastIndexOf(&quot;:&quot;);
            if (colonIdx &gt; 0) {
                src = src.substring(colonIdx + 1);
            }
            var hashIdx = src.lastIndexOf(&quot;#&quot;);
            if (hashIdx &gt; 0) {
                src = src.substring(0, hashIdx);
            }
            if (!loaded[src]) {
                loadCATMaterialRefDocument(ctx, src, function () {
                    loaded[src] = true;
                    load(i + 1, done);
                });
            } else {
                load(i + 1, done);
            }
        }

        load(0, ok);
    }

    function loadCATMaterialRefDocument(ctx, src, ok) { // Loads CATMaterialRef.3dxml
        ctx.zip.getFile(src, function (xmlDoc, json) {
            parseCATMaterialRefDocument(ctx, json, ok);
        });
    }

    function parseCATMaterialRefDocument(ctx, node, ok) { // Parse CATMaterialRef.3dxml
        // ctx.model.log(&quot;parseCATMaterialRefDocument&quot;);
        var children = node.children;
        var child;
        for (var i = 0, len = children.length; i &lt; len; i++) {
            child = children[i];
            if (child.type === &quot;Model_3dxml&quot;) {
                parseModel_3dxml(ctx, child, ok);
            }
        }
    }

    function parseModel_3dxml(ctx, node, ok) { // Parse CATMaterialRef.3dxml
        // ctx.model.log(&quot;parseModel_3dxml&quot;);
        var children = node.children;
        var child;
        for (var i = 0, len = children.length; i &lt; len; i++) {
            child = children[i];
            if (child.type === &quot;CATMaterialRef&quot;) {
                parseCATMaterialRef(ctx, child, ok);
            }
        }
    }

    function parseCATMaterialRef(ctx, node, ok) {

        // ctx.model.log(&quot;parseCATMaterialRef&quot;);

        var domainToReferenceMap = {};
        var materials = {};

        var result = {};
        var children = node.children;
        var child;
        var numToLoad = 0;

        for (var j = 0, lenj = children.length; j &lt; lenj; j++) {
            var child2 = children[j];
            switch (child2.type) {
                case &quot;MaterialDomainInstance&quot;:
                    var isAggregatedBy;
                    var isInstanceOf;
                    for (var k = 0, lenk = child2.children.length; k &lt; lenk; k++) {
                        var child3 = child2.children[k];
                        switch (child3.type) {
                            case &quot;IsAggregatedBy&quot;:
                                isAggregatedBy = child3.children[0];
                                break;
                            case &quot;IsInstanceOf&quot;:
                                isInstanceOf = child3.children[0];
                                break;
                        }
                    }
                    domainToReferenceMap[isInstanceOf] = isAggregatedBy;
                    break;
            }
        }

        for (var j = 0, lenj = children.length; j &lt; lenj; j++) {
            var child2 = children[j];
            switch (child2.type) {
                case &quot;MaterialDomain&quot;:
                    numToLoad++;
                    break;
            }
        }

        // Now load them

        for (var j = 0, lenj = children.length; j &lt; lenj; j++) {
            var child2 = children[j];
            switch (child2.type) {
                case &quot;MaterialDomain&quot;:
                    if (child2.associatedFile) {
                        (function () {
                            var childId = child2.id;
                            var src = stripURN(child2.associatedFile);
                            ctx.zip.getFile(src, function (xmlDoc, json) {
                                    // ctx.model.log(&quot;Material def loaded: &quot; + src);
                                    ctx.materials[domainToReferenceMap[childId]] = parseMaterialDefDocument(ctx, json);

                                    if (--numToLoad === 0) {
                                        //       console.log(&quot;All ReferenceReps loaded.&quot;);
                                        ok();
                                    }
                                },
                                function (error) {
                                    // TODO:
                                });
                        })();
                    }
                    break;
            }
        }
    }

    function parseMaterialDefDocument(ctx, node) {
        // ctx.model.log(&quot;parseMaterialDefDocumentOsm&quot;);
        var children = node.children;
        for (var i = 0, len = children.length; i &lt; len; i++) {
            var child = children[i];
            switch (child.type) {
                case &quot;Osm&quot;:
                    return parseMaterialDefDocumentOsm(ctx, child);
                    break;
            }
        }
    }

    function parseMaterialDefDocumentOsm(ctx, node) {
        // ctx.model.log(&quot;parseMaterialDefDocument&quot;);
        var children = node.children;
        for (var i = 0, len = children.length; i &lt; len; i++) {
            var child = children[i];
            // ctx.model.log(&quot;parseMaterialDefDocument: child.type == &quot; + child.type);
            switch (child.type) {
                case &quot;RenderingRootFeature&quot;:
                    //..
                    break;
                case &quot;Feature&quot;:

                    if (child.Alias === &quot;RenderingFeature&quot;) {
                        // Parse the coefficients, then parse the colors, scaling those by their coefficients.

                        var coeffs = {};
                        var materialCfg = {};
                        var children2 = child.children;
                        var j;
                        var lenj;
                        var child2;
                        for (j = 0, lenj = children2.length; j &lt; lenj; j++) {
                            child2 = children2[j];
                            switch (child2.Name) {
                                case &quot;AmbientCoef&quot;:
                                    coeffs.ambient = parseFloat(child2.Value);
                                    break;
                                case &quot;DiffuseCoef&quot;:
                                    coeffs.diffuse = parseFloat(child2.Value);
                                    break;
                                case &quot;EmissiveCoef&quot;:
                                    coeffs.emissive = parseFloat(child2.Value);
                                    break;
                                case &quot;SpecularExponent&quot;:
                                    coeffs.specular = parseFloat(child2.Value);
                                    break;
                            }
                        }
                        for (j = 0, lenj = children2.length; j &lt; lenj; j++) {
                            child2 = children2[j];
                            switch (child2.Name) {
                                case &quot;AmbientColor&quot;:
                                    materialCfg.ambient = parseRGB(child2.Value, coeffs.ambient);
                                    break;
                                case &quot;DiffuseColor&quot;:
                                    materialCfg.diffuse = parseRGB(child2.Value, coeffs.diffuse);
                                    break;
                                case &quot;EmissiveColor&quot;:
                                    materialCfg.emissive = parseRGB(child2.Value, coeffs.emissive);
                                    break;
                                case &quot;SpecularColor&quot;:
                                    materialCfg.specular = parseRGB(child2.Value, coeffs.specular);
                                    break;
                                case &quot;Transparency&quot;:
                                    var alpha = 1.0 - parseFloat(child2.Value); // GOTCHA: Degree of transparency, not degree of opacity
                                    if (alpha &lt; 1.0) {
                                        materialCfg.alpha = alpha;
                                        materialCfg.alphaMode = &quot;blend&quot;;
                                    }
                                    break;
                            }
                        }

                        var material;

                        switch (ctx.materialWorkflow) {
                            case &quot;MetallicMaterial&quot;:
                                material = new xeogl.MetallicMaterial(ctx.model.scene, {
                                    baseColor: materialCfg.diffuse,
                                    metallic: 0.7,
                                    roughness: 0.5,
                                    emissive: materialCfg.emissive,
                                    alpha: materialCfg.alpha,
                                    alphaMode: materialCfg.alphaMode
                                });
                                break;

                            case &quot;SpecularMaterial&quot;:
                                material = new xeogl.SpecularMaterial(ctx.model.scene, {
                                    diffuse: materialCfg.diffuse,
                                    specular: materialCfg.specular,
                                    glossiness: 0.5,
                                    emissive: materialCfg.emissive,
                                    alpha: materialCfg.alpha,
                                    alphaMode: materialCfg.alphaMode
                                });
                                break;

                            default:
                                material = new xeogl.PhongMaterial(ctx.model.scene, {
                                    reflectivity: 0.5,
                                    ambient: materialCfg.ambient,
                                    diffuse: materialCfg.diffuse,
                                    specular: materialCfg.specular,
                                    // shininess: node.shine,
                                    emissive: materialCfg.emissive,
                                    alphaMode: materialCfg.alphaMode,
                                    alpha: node.alpha
                                });
                        }

                        ctx.model._addComponent(material);
                        return material;
                    }

                    break;
            }
        }
    }

    function parseRGB(str, coeff) {
        coeff = (coeff !== undefined) ? coeff : 0.5;
        var openBracketIndex = str.indexOf(&quot;[&quot;);
        var closeBracketIndex = str.indexOf(&quot;]&quot;);
        str = str.substring(openBracketIndex + 1, closeBracketIndex - openBracketIndex);
        str = str.split(&quot;,&quot;);
        var arr = new Float32Array(str.length);
        var arrIdx = 0;
        for (var i = 0, len = str.length; i &lt; len; i++) {
            var value = str[i];
            value = value.split(&quot; &quot;);
            for (var j = 0, lenj = value.length; j &lt; lenj; j++) {
                if (value[j] !== &quot;&quot;) {
                    arr[arrIdx++] = parseFloat(value[j]) * coeff;
                }
            }
        }
        return arr;
    }


    //----------------------------------------------------------------------------------------------------

    /**
     * Wraps zip.js to provide an in-memory ZIP archive representing the 3DXML file bundle.
     *
     * Allows us to pluck each file from it as XML and JSON.
     *
     * @constructor
     */
    var ZIP = function () {

        var reader;
        var files = {};

        /**
         Loads this ZIP

         @param src
         @param ok
         @param error
         */
        this.load = function (src, ok, error) {
            var self = this;
            zip.createReader(new zip.HttpReader(src), function (reader) {
                reader.getEntries(function (entries) {
                    if (entries.length &gt; 0) {
                        for (var i = 0, len = entries.length; i &lt; len; i++) {
                            var entry = entries[i];
                            files[entry.filename] = entry;
                        }
                    }
                    ok();
                });
            }, error);
        };

        /**
         Gets a file as XML and JSON from this ZIP
         @param src
         @param ok
         @param error
         */
        this.getFile = function (src, ok, error) {
            var entry = files[src];
            if (!entry) {
                var errMsg = &quot;ZIP entry not found: &quot; + src;
                console.error(errMsg);
                if (error) {
                    error(errMsg);
                }
                return;
            }
            entry.getData(new zip.TextWriter(), function (text) {

                // Parse to XML
                var parser = new DOMParser();
                var xmlDoc = parser.parseFromString(text, &quot;text/xml&quot;);

                // Parse to JSON
                var json = xmlToJSON(xmlDoc, {});

                ok(xmlDoc, json);
            });
        };

        function xmlToJSON(node, attributeRenamer) {
            if (node.nodeType === node.TEXT_NODE) {
                var v = node.nodeValue;
                if (v.match(/^\s+$/) === null) {
                    return v;
                }
            } else if (node.nodeType === node.ELEMENT_NODE ||
                node.nodeType === node.DOCUMENT_NODE) {
                var json = {type: node.nodeName, children: []};
                if (node.nodeType === node.ELEMENT_NODE) {
                    for (var j = 0; j &lt; node.attributes.length; j++) {
                        var attribute = node.attributes[j];
                        var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;
                        json[nm] = attribute.nodeValue;
                    }
                }
                for (var i = 0; i &lt; node.childNodes.length; i++) {
                    var item = node.childNodes[i];
                    var j = xmlToJSON(item, attributeRenamer);
                    if (j) json.children.push(j);
                }
                return json;
            }
        }

        /**
         Disposes of this ZIP
         */
        this.destroy = function () {
            reader.close(function () {
                // onclose callback
            });
        };
    };

    function loadZIP(src, ok, err) {
        var zip = new ZIP();
        zip.load(src, function () {
            ok(zip);
        }, function (errMsg) {
            err(&quot;Error loading ZIP archive: &quot; + errMsg);
        })
    }

    // function loadXML(url, ok, err) {
    //     var request = new XMLHttpRequest();
    //     request.overrideMimeType(&quot;text/xml&quot;);
    //     request.open(&#x27;GET&#x27;, url, true);
    //     request.addEventListener(&#x27;load&#x27;, function (event) {
    //         //var response = event.target.response;
    //         if (this.status === 200) {
    //             if (ok) {
    //                 var parser = new DOMParser();
    //                 var xmlDoc = parser.parseFromString(request.responseText, &quot;text/xml&quot;);
    //                 ok(xmlDoc, this);
    //             }
    //         } else if (this.status === 0) {
    //             // Some browsers return HTTP Status 0 when using non-http protocol
    //             // e.g. &#x27;file://&#x27; or &#x27;data://&#x27;. Handle as success.
    //             console.warn(&#x27;loadFile: HTTP Status 0 received.&#x27;);
    //             if (ok) {
    //                 var parser = new DOMParser();
    //                 var xmlDoc = parser.parseFromString(request.responseText, &quot;text/xml&quot;);
    //                 ok(xmlDoc, this);
    //             }
    //         } else {
    //             if (err) {
    //                 err(event);
    //             }
    //         }
    //     }, false);
    //
    //     request.addEventListener(&#x27;error&#x27;, function (event) {
    //         if (err) {
    //             err(event);
    //         }
    //     }, false);
    //     request.send(null);
    // }
    //
    // function xmlToJSON(node, attributeRenamer) {
    //     if (node.nodeType === node.TEXT_NODE) {
    //         var v = node.nodeValue;
    //         if (v.match(/^\s+$/) === null) {
    //             return v;
    //         }
    //     } else if (node.nodeType === node.ELEMENT_NODE ||
    //         node.nodeType === node.DOCUMENT_NODE) {
    //         var json = {type: node.nodeName, children: []};
    //         if (node.nodeType === node.ELEMENT_NODE) {
    //             for (var j = 0; j &lt; node.attributes.length; j++) {
    //                 var attribute = node.attributes[j];
    //                 var nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;
    //                 json[nm] = attribute.nodeValue;
    //             }
    //         }
    //         for (var i = 0; i &lt; node.childNodes.length; i++) {
    //             var item = node.childNodes[i];
    //             var j = xmlToJSON(item, attributeRenamer);
    //             if (j) json.children.push(j);
    //         }
    //         return json;
    //     }
    // }

    function stripURN(str) {
        var subStr = &quot;urn:3DXML:&quot;;
        return (str.indexOf(subStr) === 0) ? str.substring(subStr.length) : str;
    }


    function getIDFromURI(str) {
        var hashIdx = str.lastIndexOf(&quot;#&quot;);
        return hashIdx != -1 ? str.substring(hashIdx + 1) : str;
    }

})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
