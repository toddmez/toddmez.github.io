<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/lindsay/xeolabs/xeogl-next/xeogl/examples/js/models/OBJModel.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">

    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
            
                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
            
                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
            
                <li><a href="../classes/Annotation.html">Annotation</a></li>
            
                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
            
                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
            
                <li><a href="../classes/BIMServerModel.html">BIMServerModel</a></li>
            
                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
            
                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
            
                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
            
                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
            
                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
            
                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/Clip.html">Clip</a></li>
            
                <li><a href="../classes/ClipControl.html">ClipControl</a></li>
            
                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
            
                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
            
                <li><a href="../classes/Curve.html">Curve</a></li>
            
                <li><a href="../classes/CustomProjection.html">CustomProjection</a></li>
            
                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
            
                <li><a href="../classes/DirLight.html">DirLight</a></li>
            
                <li><a href="../classes/EdgeMaterial.html">EdgeMaterial</a></li>
            
                <li><a href="../classes/EmphasisMaterial.html">EmphasisMaterial</a></li>
            
                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
            
                <li><a href="../classes/Frustum.html">Frustum</a></li>
            
                <li><a href="../classes/Geometry.html">Geometry</a></li>
            
                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
            
                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/LambertMaterial.html">LambertMaterial</a></li>
            
                <li><a href="../classes/LightMap.html">LightMap</a></li>
            
                <li><a href="../classes/Material.html">Material</a></li>
            
                <li><a href="../classes/Mesh.html">Mesh</a></li>
            
                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
            
                <li><a href="../classes/Model.html">Model</a></li>
            
                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
            
                <li><a href="../classes/Ortho.html">Ortho</a></li>
            
                <li><a href="../classes/OutlineMaterial.html">OutlineMaterial</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
            
                <li><a href="../classes/Perspective.html">Perspective</a></li>
            
                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
            
                <li><a href="../classes/Pin.html">Pin</a></li>
            
                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
            
                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
            
                <li><a href="../classes/PointLight.html">PointLight</a></li>
            
                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
            
                <li><a href="../classes/ReflectionMap.html">ReflectionMap</a></li>
            
                <li><a href="../classes/Scene.html">Scene</a></li>
            
                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
            
                <li><a href="../classes/Shadow.html">Shadow</a></li>
            
                <li><a href="../classes/Skybox.html">Skybox</a></li>
            
                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
            
                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
            
                <li><a href="../classes/Spinner.html">Spinner</a></li>
            
                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
            
                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
            
                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
            
                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
            
                <li><a href="../classes/STLModel.html">STLModel</a></li>
            
                <li><a href="../classes/Story.html">Story</a></li>
            
                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
            
                <li><a href="../classes/TestModel.html">TestModel</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
            
                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
            
                <li><a href="../classes/Viewport.html">Viewport</a></li>
            
                <li><a href="../classes/xeogl.xeogl.html">xeogl.xeogl</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..//modules/animation.html">animation</a></li>
            
                <li><a href="..//modules/annotations.html">annotations</a></li>
            
                <li><a href="..//modules/camera.html">camera</a></li>
            
                <li><a href="..//modules/canvas.html">canvas</a></li>
            
                <li><a href="..//modules/clipping.html">clipping</a></li>
            
                <li><a href="..//modules/controls.html">controls</a></li>
            
                <li><a href="..//modules/curves.html">curves</a></li>
            
                <li><a href="..//modules/effects.html">effects</a></li>
            
                <li><a href="..//modules/generation.html">generation</a></li>
            
                <li><a href="..//modules/geometry.html">geometry</a></li>
            
                <li><a href="..//modules/helpers.html">helpers</a></li>
            
                <li><a href="..//modules/input.html">input</a></li>
            
                <li><a href="..//modules/lighting.html">lighting</a></li>
            
                <li><a href="..//modules/materials.html">materials</a></li>
            
                <li><a href="..//modules/math.html">math</a></li>
            
                <li><a href="..//modules/meshes.html">meshes</a></li>
            
                <li><a href="..//modules/models.html">models</a></li>
            
                <li><a href="..//modules/objects.html">objects</a></li>
            
                <li><a href="..//modules/rendering.html">rendering</a></li>
            
                <li><a href="..//modules/scene.html">scene</a></li>
            
                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
            
                <li><a href="..//modules/stories.html">stories</a></li>
            
                <li><a href="..//modules/xeogl.html">xeogl</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
        <!--Show:-->
        <!--<label for="api-show-inherited">-->
            <!--<input type="checkbox" id="api-show-inherited" checked>-->
            <!--Inherited-->
        <!--</label>-->

        <!--<label for="api-show-protected">-->
            <!--<input type="checkbox" id="api-show-protected">-->
            <!--Protected-->
        <!--</label>-->

        <!--<label for="api-show-private">-->
            <!--<input type="checkbox" id="api-show-private">-->
            <!--Private-->
        <!--</label>-->
        <!--<label for="api-show-deprecated">-->
            <!--<input type="checkbox" id="api-show-deprecated">-->
            <!--Deprecated-->
        <!--</label>-->

    <!--</div>-->


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/lindsay/xeolabs/xeogl-next/xeogl/examples/js/models/OBJModel.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 An **OBJModel** is a {{#crossLink &quot;Model&quot;}}{{/crossLink}} that loads itself from OBJ and MTL files.

 &lt;a href=&quot;../../examples/#importing_obj_conferenceRoom&quot;&gt;&lt;img src=&quot;../../../assets/images/screenshots/OBJModel.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 ## Overview

 * Begins loading as soon as you set its {{#crossLink &quot;OBJModel/src:property&quot;}}{{/crossLink}} property to the location of an OBJ file.
 * Once loaded, contains an {{#crossLink &quot;Mesh&quot;}}{{/crossLink}} for each object. The {{#crossLink &quot;Mesh&quot;}}Meshes{{/crossLink}} can then be independently shown, hidden, colored, transformed etc.
 * Set {{#crossLink &quot;OBJModel/src:property&quot;}}{{/crossLink}} to a new file path at any time, to clear the OBJModel and load components from the new file.

 OBJModel inherits these capabilities from its {{#crossLink &quot;Group&quot;}}{{/crossLink}} base class:

 * Allows you to access and manipulate the {{#crossLink &quot;Meshes&quot;}}{{/crossLink}} within it.
 * Can be transformed as a unit within World-space.
 * Can be a child within a parent {{#crossLink &quot;Group&quot;}}{{/crossLink}}.
 * Provides its World-space axis-aligned and object-aligned boundaries.

 ## Examples

 * [Basic example](../../examples/#importing_obj_people)
 * [Models within an object hierarchy](../../examples/#objects_hierarchy_models)

 ## Usage

 Let&#x27;s load the conference room model (shown in the screenshot above):

 &#x60;&#x60;&#x60;&#x60;javascript
 var confRoom = new xeogl.OBJModel({
     id: &quot;confRoom&quot;,
     src: &quot;models/obj/conference/conference.obj&quot;
 });
 &#x60;&#x60;&#x60;&#x60;

 Bind a callback to fire when the model has loaded:

 &#x60;&#x60;&#x60;&#x60;javascript
 confRoom.on(&quot;loaded&quot;, function() {
     // OBJModel has loaded!
 });
 &#x60;&#x60;&#x60;&#x60;

 That fires immediately if the OBJModel already happens to be loaded. You can also bind a callback to fire if loading fails:

 &#x60;&#x60;&#x60;&#x60;javascript
 confRoom.on(&quot;error&quot;, function(msg) {
     // Error occurred
 });
 &#x60;&#x60;&#x60;&#x60;

 To switch to a different OBJ file, simply update {{#crossLink &quot;OBJModel/src:property&quot;}}{{/crossLink}}:

 &#x60;&#x60;&#x60;&#x60;javascript
 confRoom.src = &quot;models/obj/female02/female02.obj&quot;;
 &#x60;&#x60;&#x60;&#x60;

 ### Fitting to view

 &#x60;&#x60;&#x60;&#x60;javascript
 var cameraFlight = new xeogl.CameraFlightAnimation();
 cameraFlight.flyTo(confRoom);
 &#x60;&#x60;&#x60;&#x60;

 ### Accessing components

 Let&#x27;s make everything  transparent, except for the conference table and chairs:

 &#x60;&#x60;&#x60;&#x60;javascript
 for (var id in confRoom.meshes) {
    var mesh = confRoom.meshes[id];
    switch (id) {
        case &quot;confRoom#mesh31&quot;:
        case &quot;confRoom#mesh29&quot;:
        case &quot;confRoom#mesh30&quot;:
            break;
        default: // Not a chair mesh
            mesh.material.alpha = 0.5;
            mesh.material.blendMode = &quot;blend&quot;
    }
 }
 &#x60;&#x60;&#x60;&#x60;

 Note the format of the {{#crossLink &quot;Mesh&quot;}}{{/crossLink}} IDs - an OBJModel prefixes its own ID to the IDs of its components:

 &#x60;&#x60;&#x60;&#x60;&lt;OBJModel ID&gt;#&lt;OBJ object/group ID&gt;&#x60;&#x60;&#x60;&#x60;

 **Transforms**

 An OBJModel lets us transform its Meshes as a group:

 &#x60;&#x60;&#x60;&#x60; Javascript
 var model = new xeogl.OBJModel({
     src: &quot;models/obj/conference/conference.obj&quot;
     position: [-35, 0, 0],
     rotation: [0, 45, 0],
     scale: [0.5, 0.5, 0.5]
 });

 model.position = [-20, 0, 0];
 &#x60;&#x60;&#x60;&#x60;

 Let&#x27;s move the white table top upwards:

 &#x60;&#x60;&#x60;&#x60;javascript
 var tableTop = confRoom.meshes[&quot;confRoom#mesh29&quot;];
 tableTop.position = [0, 150, 0];
 &#x60;&#x60;&#x60;&#x60;

 ## Examples

 * [Conference room model](../../examples/#importing_obj_conferenceRoom)
 * [Two character models](../../examples/#importing_obj_people)

 @class OBJModel
 @module xeogl
 @submodule models
 @constructor
 @param [scene] {Scene} Parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} - creates this OBJModel in the default
 {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.entityType] {String} Optional entity classification when using within a semantic data model. See the {{#crossLink &quot;Object&quot;}}{{/crossLink}} documentation for usage.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this OBJModel.
 @param [cfg.src] {String} Path to an OBJ file. You can set this to a new file path at any time, which will cause the
 OBJModel to load components from the new file (after first destroying any components loaded from a previous file path).
 @param [cfg.quantizeGeometry=true] {Boolean} When true, quantizes geometry to reduce memory and GPU bus usage.
 @param [cfg.combineGeometry=true] {Boolean} When true, combines geometry vertex buffers to improve rendering performance.
 @param [cfg.ghosted=false] {Boolean} When true, sets all the OBJModel&#x27;s Meshes initially ghosted.
 @param [cfg.highlighted=false] {Boolean} When true, sets all the OBJModel&#x27;s Meshes initially highlighted.
 @param [cfg.outline=false] {Boolean} When true, sets all the OBJModel&#x27;s Meshes initially outlined.
 @param [cfg.edgeThreshold=2] {Number} When ghosting, this is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.
 @param [cfg.transform] {Number|String|Transform} A Local-to-World-space (modelling) {{#crossLink &quot;Transform&quot;}}{{/crossLink}} to attach to this OBJModel.
 Must be within the same {{#crossLink &quot;Scene&quot;}}{{/crossLink}} as this STLModel. Internally, the given
 {{#crossLink &quot;Transform&quot;}}{{/crossLink}} will be inserted above each top-most {{#crossLink &quot;Transform&quot;}}Transform{{/crossLink}}
 that the STLModel attaches to its {{#crossLink &quot;Mesh&quot;}}Meshes{{/crossLink}}.
 @param [cfg.splitMeshes=true] {Boolean} When true, creates a separate {{#crossLink &quot;Mesh&quot;}}{{/crossLink}} for each group of faces that share the same vertex colors. Only works with binary STL.|
 @param [cfg.position=[0,0,0]] {Float32Array} The STLModel&#x27;s local 3D position.
 @param [cfg.scale=[1,1,1]] {Float32Array} The STLModel&#x27;s local scale.
 @param [cfg.rotation=[0,0,0]] {Float32Array} The STLModel&#x27;s local rotation, as Euler angles given in degrees.
 @param [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1] {Float32Array} The STLModel&#x27;s local transform matrix. Overrides the position, scale and rotation parameters.
 @extends Model
 */
{

    xeogl.OBJModel = class xeoglOBJModel extends xeogl.Model {


        init(cfg) {
            super.init(cfg);
            this._src = null;
            this.src = cfg.src;
        }


        /**
         Path to a Wavefront OBJ file.

         You can set this to a new file path at any time, which will cause the OBJModel to load components from
         the new file (after first destroying any components loaded from a previous file path).

         Also loads materials from any MTL files referenced in the OBJ.

         Fires a {{#crossLink &quot;OBJModel/src:event&quot;}}{{/crossLink}} event on change.

         @property src
         @type String
         */
        set src(value) {

            if (!value) {
                return;
            }

            if (!xeogl._isString(value)) {
                this.error(&quot;Value for &#x27;src&#x27; should be a string&quot;);
                return;
            }

            if (value === this._src) { // Already loaded this OBJModel

                /**
                 Fired whenever this OBJModel has finished loading components from the OBJ file
                 specified by {{#crossLink &quot;OBJModel/src:property&quot;}}{{/crossLink}}.
                 @event loaded
                 */
                this.fire(&quot;loaded&quot;, true, true);

                return;
            }

            this.destroyAll();

            this._src = value;

            xeogl.OBJModel.load(this, this._src);

            /**
             Fired whenever this OBJModel&#x27;s {{#crossLink &quot;OBJModel/src:property&quot;}}{{/crossLink}} property changes.
             @event src
             @param value The property&#x27;s new value
             */
            this.fire(&quot;src&quot;, this._src);
        }

        get src() {
            return this._src;
        }


        /**
         * Loads OBJ and MTL from file(s) into a {{#crossLink &quot;Model&quot;}}{{/crossLink}}.
         *
         * @method load
         * @static
         * @param {Model} model Model to load into.
         * @param {String} src Path to OBJ file.
         * @param {Function} [ok] Completion callback.
         */
        static load(model, src, ok) {

            var spinner = model.scene.canvas.spinner;
            spinner.processes++;

            loadOBJ(model, src, function (state) {
                loadMTLs(model, state, function () {

                    createMeshes(model, state);

                    spinner.processes--;

                    xeogl.scheduleTask(function () {
                        model.fire(&quot;loaded&quot;, true);
                    });

                    if (ok) {
                        ok();
                    }
                });
            });
        }

        /**
         * Parses OBJ and MTL text strings into a {{#crossLink &quot;Model&quot;}}{{/crossLink}}.
         *
         * @method parse
         * @static
         * @param {Model} model Model to load into.
         * @param {String} objText OBJ text string.
         * @param {String} [mtlText] MTL text string.
         * @param {String} [basePath] Base path for external resources.
         */
        static parse(model, objText, mtlText, basePath) {
            if (!objText) {
                this.warn(&quot;load() param expected: objText&quot;);
                return;
            }
            var state = parseOBJ(model, objText, null);
            if (mtlText) {
                parseMTL(model, mtlText, basePath);
            }
            createMeshes(model, state);
            model.src = null;
            model.fire(&quot;loaded&quot;, true, true);
        }
    };

//--------------------------------------------------------------------------------------------
// Loads OBJ
//
// Parses OBJ into an intermediate state object. The object will contain geometry data
// and material IDs from which meshes can be created later. The object will also
// contain a list of filenames of the MTL files referenced by the OBJ, is any.
//
// Originally based on the THREE.js OBJ and MTL loaders:
//
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js
// https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/MTLLoader.js
//--------------------------------------------------------------------------------------------

    var loadOBJ = function (model, url, ok) {

        loadFile(url, function (text) {
                var state = parseOBJ(model, text, url);
                ok(state);
            },
            function (error) {
                model.error(error);
            });
    };

    var parseOBJ = (function () {

        const regexp = {
            // v float float float
            vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            // vn float float float
            normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            // vt float float
            uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            // f vertex vertex vertex
            face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
            // f vertex/uv vertex/uv vertex/uv
            face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
            face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
            // f vertex//normal vertex//normal vertex//normal
            face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
            // o object_name | g group_name
            object_pattern: /^[og]\s*(.+)?/,
            // s boolean
            smoothing_pattern: /^s\s+(\d+|on|off)/,
            // mtllib file_reference
            material_library_pattern: /^mtllib /,
            // usemtl material_name
            material_use_pattern: /^usemtl /
        };

        return function (model, text, url) {

            url = url || &quot;&quot;

            var state = {
                src: url,
                basePath: getBasePath(url),
                objects: [],
                object: {},
                positions: [],
                normals: [],
                uv: [],
                materialLibraries: {}
            };

            startObject(state, &quot;&quot;, false);

            // Parts of this parser logic are derived from the THREE.js OBJ loader:
            // https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js

            if (text.indexOf(&#x27;\r\n&#x27;) !== -1) {
                // This is faster than String.split with regex that splits on both
                text = text.replace(&#x27;\r\n&#x27;, &#x27;\n&#x27;);
            }

            var lines = text.split(&#x27;\n&#x27;);
            var line = &#x27;&#x27;, lineFirstChar = &#x27;&#x27;, lineSecondChar = &#x27;&#x27;;
            var lineLength = 0;
            var result = [];

            // Faster to just trim left side of the line. Use if available.
            var trimLeft = ( typeof &#x27;&#x27;.trimLeft === &#x27;function&#x27; );

            for (var i = 0, l = lines.length; i &lt; l; i++) {

                line = lines[i];

                line = trimLeft ? line.trimLeft() : line.trim();

                lineLength = line.length;

                if (lineLength === 0) {
                    continue;
                }

                lineFirstChar = line.charAt(0);

                if (lineFirstChar === &#x27;#&#x27;) {
                    continue;
                }

                if (lineFirstChar === &#x27;v&#x27;) {

                    lineSecondChar = line.charAt(1);

                    if (lineSecondChar === &#x27; &#x27; &amp;&amp; ( result = regexp.vertex_pattern.exec(line) ) !== null) {

                        // 0                  1      2      3
                        // [&#x27;v 1.0 2.0 3.0&#x27;, &#x27;1.0&#x27;, &#x27;2.0&#x27;, &#x27;3.0&#x27;]

                        state.positions.push(
                            parseFloat(result[1]),
                            parseFloat(result[2]),
                            parseFloat(result[3])
                        );

                    } else if (lineSecondChar === &#x27;n&#x27; &amp;&amp; ( result = regexp.normal_pattern.exec(line) ) !== null) {

                        // 0                   1      2      3
                        // [&#x27;vn 1.0 2.0 3.0&#x27;, &#x27;1.0&#x27;, &#x27;2.0&#x27;, &#x27;3.0&#x27;]

                        state.normals.push(
                            parseFloat(result[1]),
                            parseFloat(result[2]),
                            parseFloat(result[3])
                        );

                    } else if (lineSecondChar === &#x27;t&#x27; &amp;&amp; ( result = regexp.uv_pattern.exec(line) ) !== null) {

                        // 0               1      2
                        // [&#x27;vt 0.1 0.2&#x27;, &#x27;0.1&#x27;, &#x27;0.2&#x27;]

                        state.uv.push(
                            parseFloat(result[1]),
                            parseFloat(result[2])
                        );

                    } else {

                        model.error(&#x27;Unexpected vertex/normal/uv line: \&#x27;&#x27; + line + &#x27;\&#x27;&#x27;);
                        return;
                    }

                } else if (lineFirstChar === &#x27;f&#x27;) {

                    if (( result = regexp.face_vertex_uv_normal.exec(line) ) !== null) {

                        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
                        // 0                        1    2    3    4    5    6    7    8    9   10         11         12
                        // [&#x27;f 1/1/1 2/2/2 3/3/3&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, undefined, undefined, undefined]

                        addFace(state,
                            result[1], result[4], result[7], result[10],
                            result[2], result[5], result[8], result[11],
                            result[3], result[6], result[9], result[12]
                        );

                    } else if (( result = regexp.face_vertex_uv.exec(line) ) !== null) {

                        // f vertex/uv vertex/uv vertex/uv
                        // 0                  1    2    3    4    5    6   7          8
                        // [&#x27;f 1/1 2/2 3/3&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, undefined, undefined]

                        addFace(state,
                            result[1], result[3], result[5], result[7],
                            result[2], result[4], result[6], result[8]
                        );

                    } else if (( result = regexp.face_vertex_normal.exec(line) ) !== null) {

                        // f vertex//normal vertex//normal vertex//normal
                        // 0                     1    2    3    4    5    6   7          8
                        // [&#x27;f 1//1 2//2 3//3&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, undefined, undefined]

                        addFace(state,
                            result[1], result[3], result[5], result[7],
                            undefined, undefined, undefined, undefined,
                            result[2], result[4], result[6], result[8]
                        );

                    } else if (( result = regexp.face_vertex.exec(line) ) !== null) {

                        // f vertex vertex vertex
                        // 0            1    2    3   4
                        // [&#x27;f 1 2 3&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, undefined]

                        addFace(state, result[1], result[2], result[3], result[4]);
                    } else {
                        model.error(&#x27;Unexpected face line: \&#x27;&#x27; + line + &#x27;\&#x27;&#x27;);
                        return;
                    }

                } else if (lineFirstChar === &#x27;l&#x27;) {

                    var lineParts = line.substring(1).trim().split(&#x27; &#x27;);
                    var lineVertices = [], lineUVs = [];

                    if (line.indexOf(&#x27;/&#x27;) === -1) {

                        lineVertices = lineParts;

                    } else {
                        for (var li = 0, llen = lineParts.length; li &lt; llen; li++) {
                            var parts = lineParts[li].split(&#x27;/&#x27;);
                            if (parts[0] !== &#x27;&#x27;) {
                                lineVertices.push(parts[0]);
                            }
                            if (parts[1] !== &#x27;&#x27;) {
                                lineUVs.push(parts[1]);
                            }
                        }
                    }
                    addLineGeometry(state, lineVertices, lineUVs);

                } else if (( result = regexp.object_pattern.exec(line) ) !== null) {

                    // o object_name
                    // or
                    // g group_name

                    var id = result[0].substr(1).trim();
                    startObject(state, id, true);

                } else if (regexp.material_use_pattern.test(line)) {

                    // material

                    var id = line.substring(7).trim();
                    state.object.material.id = id;

                } else if (regexp.material_library_pattern.test(line)) {

                    // mtl file

                    state.materialLibraries[line.substring(7).trim()] = true;

                } else if (( result = regexp.smoothing_pattern.exec(line) ) !== null) {

                    // smooth shading

                    var value = result[1].trim().toLowerCase();
                    state.object.material.smooth = ( value === &#x27;1&#x27; || value === &#x27;on&#x27; );

                } else {

                    // Handle null terminated files without exception
                    if (line === &#x27;\0&#x27;) {
                        continue;
                    }

                    model.error(&#x27;Unexpected line: \&#x27;&#x27; + line + &#x27;\&#x27;&#x27;);
                    return;
                }
            }

            return state;
        };

        function getBasePath(src) {
            var n = src.lastIndexOf(&#x27;/&#x27;);
            return (n === -1) ? src : src.substring(0, n + 1);
        }

        function startObject(state, id, fromDeclaration) {
            if (state.object &amp;&amp; state.object.fromDeclaration === false) {
                state.object.id = id;
                state.object.fromDeclaration = ( fromDeclaration !== false );
                return;
            }
            state.object = {
                id: id || &#x27;&#x27;,
                geometry: {
                    positions: [],
                    normals: [],
                    uv: []
                },
                material: {
                    id: &#x27;&#x27;,
                    smooth: true
                },
                fromDeclaration: ( fromDeclaration !== false )
            };
            state.objects.push(state.object);
        }

        function parseVertexIndex(value, len) {
            var index = parseInt(value, 10);
            return ( index &gt;= 0 ? index - 1 : index + len / 3 ) * 3;
        }

        function parseNormalIndex(value, len) {
            var index = parseInt(value, 10);
            return ( index &gt;= 0 ? index - 1 : index + len / 3 ) * 3;
        }

        function parseUVIndex(value, len) {
            var index = parseInt(value, 10);
            return ( index &gt;= 0 ? index - 1 : index + len / 2 ) * 2;
        }

        function addVertex(state, a, b, c) {
            var src = state.positions;
            var dst = state.object.geometry.positions;
            dst.push(src[a + 0]);
            dst.push(src[a + 1]);
            dst.push(src[a + 2]);
            dst.push(src[b + 0]);
            dst.push(src[b + 1]);
            dst.push(src[b + 2]);
            dst.push(src[c + 0]);
            dst.push(src[c + 1]);
            dst.push(src[c + 2]);
        }

        function addVertexLine(state, a) {
            var src = state.positions;
            var dst = state.object.geometry.positions;
            dst.push(src[a + 0]);
            dst.push(src[a + 1]);
            dst.push(src[a + 2]);
        }

        function addNormal(state, a, b, c) {
            var src = state.normals;
            var dst = state.object.geometry.normals;
            dst.push(src[a + 0]);
            dst.push(src[a + 1]);
            dst.push(src[a + 2]);
            dst.push(src[b + 0]);
            dst.push(src[b + 1]);
            dst.push(src[b + 2]);
            dst.push(src[c + 0]);
            dst.push(src[c + 1]);
            dst.push(src[c + 2]);
        }

        function addUV(state, a, b, c) {
            var src = state.uv;
            var dst = state.object.geometry.uv;
            dst.push(src[a + 0]);
            dst.push(src[a + 1]);
            dst.push(src[b + 0]);
            dst.push(src[b + 1]);
            dst.push(src[c + 0]);
            dst.push(src[c + 1]);
        }

        function addUVLine(state, a) {
            var src = state.uv;
            var dst = state.object.geometry.uv;
            dst.push(src[a + 0]);
            dst.push(src[a + 1]);
        }

        function addFace(state, a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
            var vLen = state.positions.length;
            var ia = parseVertexIndex(a, vLen);
            var ib = parseVertexIndex(b, vLen);
            var ic = parseVertexIndex(c, vLen);
            var id;
            if (d === undefined) {
                addVertex(state, ia, ib, ic);

            } else {
                id = parseVertexIndex(d, vLen);
                addVertex(state, ia, ib, id);
                addVertex(state, ib, ic, id);
            }

            if (ua !== undefined) {

                var uvLen = state.uv.length;

                ia = parseUVIndex(ua, uvLen);
                ib = parseUVIndex(ub, uvLen);
                ic = parseUVIndex(uc, uvLen);

                if (d === undefined) {
                    addUV(state, ia, ib, ic);

                } else {
                    id = parseUVIndex(ud, uvLen);
                    addUV(state, ia, ib, id);
                    addUV(state, ib, ic, id);
                }
            }

            if (na !== undefined) {

                // Normals are many times the same. If so, skip function call and parseInt.

                var nLen = state.normals.length;

                ia = parseNormalIndex(na, nLen);
                ib = na === nb ? ia : parseNormalIndex(nb, nLen);
                ic = na === nc ? ia : parseNormalIndex(nc, nLen);

                if (d === undefined) {
                    addNormal(state, ia, ib, ic);

                } else {

                    id = parseNormalIndex(nd, nLen);
                    addNormal(state, ia, ib, id);
                    addNormal(state, ib, ic, id);
                }
            }
        }

        function addLineGeometry(state, positions, uv) {

            state.object.geometry.type = &#x27;Line&#x27;;

            var vLen = state.positions.length;
            var uvLen = state.uv.length;

            for (var vi = 0, l = positions.length; vi &lt; l; vi++) {
                addVertexLine(state, parseVertexIndex(positions[vi], vLen));
            }

            for (var uvi = 0, uvl = uv.length; uvi &lt; uvl; uvi++) {
                addUVLine(state, parseUVIndex(uv[uvi], uvLen));
            }
        }
    })();

//--------------------------------------------------------------------------------------------
// Loads MTL files listed in parsed state
//--------------------------------------------------------------------------------------------

    function loadMTLs(model, state, ok) {
        var basePath = state.basePath;
        var srcList = Object.keys(state.materialLibraries);
        var numToLoad = srcList.length;
        for (var i = 0, len = numToLoad; i &lt; len; i++) {
            loadMTL(model, basePath, basePath + srcList[i], function () {
                if (--numToLoad === 0) {
                    ok();
                }
            });
        }
    }

//--------------------------------------------------------------------------------------------
// Loads an MTL file
//--------------------------------------------------------------------------------------------

    var loadMTL = function (model, basePath, src, ok) {
        loadFile(src, function (text) {
                parseMTL(model, text, basePath);
                ok();
            },
            function (error) {
                model.error(error);
                ok();
            });
    };

    var parseMTL = (function () {

        var delimiter_pattern = /\s+/;

        return function (model, mtlText, basePath) {

            var lines = mtlText.split(&#x27;\n&#x27;);
            var materialCfg = {
                id: &quot;Default&quot;
            };
            var needCreate = false;
            var line;
            var pos;
            var key;
            var value;
            var alpha;

            basePath = basePath || &quot;&quot;;

            for (var i = 0; i &lt; lines.length; i++) {

                line = lines[i].trim();

                if (line.length === 0 || line.charAt(0) === &#x27;#&#x27;) { // Blank line or comment ignore
                    continue;
                }

                pos = line.indexOf(&#x27; &#x27;);

                key = ( pos &gt;= 0 ) ? line.substring(0, pos) : line;
                key = key.toLowerCase();

                value = ( pos &gt;= 0 ) ? line.substring(pos + 1) : &#x27;&#x27;;
                value = value.trim();

                switch (key.toLowerCase()) {

                    case &quot;newmtl&quot;: // New material
                        //if (needCreate) {
                        createMaterial(model, materialCfg);
                        //}
                        materialCfg = {
                            id: value
                        };
                        needCreate = true;
                        break;

                    case &#x27;ka&#x27;:
                        materialCfg.ambient = parseRGB(value);
                        break;

                    case &#x27;kd&#x27;:
                        materialCfg.diffuse = parseRGB(value);
                        break;

                    case &#x27;ks&#x27;:
                        materialCfg.specular = parseRGB(value);
                        break;

                    case &#x27;map_kd&#x27;:
                        if (!materialCfg.diffuseMap) {
                            materialCfg.diffuseMap = createTexture(model, basePath, value, &quot;sRGB&quot;);
                        }
                        break;

                    case &#x27;map_ks&#x27;:
                        if (!materialCfg.specularMap) {
                            materialCfg.specularMap = createTexture(model, basePath, value, &quot;linear&quot;);
                        }
                        break;

                    case &#x27;map_bump&#x27;:
                    case &#x27;bump&#x27;:
                        if (!materialCfg.normalMap) {
                            materialCfg.normalMap = createTexture(model, basePath, value);
                        }
                        break;

                    case &#x27;ns&#x27;:
                        materialCfg.shininess = parseFloat(value);
                        break;

                    case &#x27;d&#x27;:
                        alpha = parseFloat(value);
                        if (alpha &lt; 1) {
                            materialCfg.alpha = alpha;
                            materialCfg.alphaMode = &quot;blend&quot;;
                        }
                        break;

                    case &#x27;tr&#x27;:
                        alpha = parseFloat(value);
                        if (alpha &gt; 0) {
                            materialCfg.alpha = 1 - alpha;
                            materialCfg.alphaMode = &quot;blend&quot;;
                        }
                        break;

                    default:
                    // model.error(&quot;Unrecognized token: &quot; + key);
                }
            }

            if (needCreate) {
                createMaterial(model, materialCfg);
            }
        };

        function createTexture(model, basePath, value, encoding) {
            var textureCfg = {};
            var items = value.split(/\s+/);
            var pos = items.indexOf(&#x27;-bm&#x27;);
            if (pos &gt;= 0) {
                //matParams.bumpScale = parseFloat(items[pos + 1]);
                items.splice(pos, 2);
            }
            pos = items.indexOf(&#x27;-s&#x27;);
            if (pos &gt;= 0) {
                textureCfg.scale = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
                items.splice(pos, 4); // we expect 3 parameters here!
            }
            pos = items.indexOf(&#x27;-o&#x27;);
            if (pos &gt;= 0) {
                textureCfg.translate = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
                items.splice(pos, 4); // we expect 3 parameters here!
            }
            textureCfg.src = basePath + items.join(&#x27; &#x27;).trim();
            textureCfg.flipY = true;
            textureCfg.encoding = encoding || &quot;linear&quot;;
            //textureCfg.wrapS = self.wrap;
            //textureCfg.wrapT = self.wrap;
            var texture = new xeogl.Texture(model, textureCfg);
            model._addComponent(texture);
            return texture.id;
        }

        function createMaterial(model, materialCfg) {
            model._addComponent(new xeogl.PhongMaterial(model, materialCfg));
        }

        function parseRGB(value) {
            var ss = value.split(delimiter_pattern, 3);
            return [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
        }

    })();
//--------------------------------------------------------------------------------------------
// Creates meshes from parsed state
//--------------------------------------------------------------------------------------------

    var createMeshes = (function () {

        return function (model, state) {

            for (var j = 0, k = state.objects.length; j &lt; k; j++) {

                var object = state.objects[j];
                var geometry = object.geometry;
                var isLine = ( geometry.type === &#x27;Line&#x27; );

                if (geometry.positions.length === 0) {
                    // Skip o/g line declarations that did not follow with any faces
                    continue;
                }

                var geometryCfg = {
                    primitive: &quot;triangles&quot;
                };

                geometryCfg.positions = geometry.positions;

                if (geometry.normals.length &gt; 0) {
                    geometryCfg.normals = geometry.normals;
                } else {
                    geometryCfg.autoVertexNormals = true;
                }

                if (geometry.uv.length &gt; 0) {
                    geometryCfg.uv = geometry.uv;
                }

                var indices = new Array(geometryCfg.positions.length / 3); // Triangle soup
                for (var idx = 0; idx &lt; indices.length; idx++) {
                    indices[idx] = idx;
                }
                geometryCfg.indices = indices;

                var xeoGeometry = new xeogl.Geometry(model, geometryCfg);
                model._addComponent(xeoGeometry);

                var materialId = object.material.id;
                var material;
                if (materialId &amp;&amp; materialId !== &quot;&quot;) {
                    material = model.scene.components[materialId];
                    if (!material) {
                        model.error(&quot;Material not found: &quot; + materialId);
                    }
                } else {
                    material = new xeogl.PhongMaterial(model, {
                        //emissive: [0.6, 0.6, 0.0],
                        diffuse: [0.6, 0.6, 0.6],
                        backfaces: true
                    });
                    model._addComponent(material);
                }

                // material.emissive = [Math.random(), Math.random(), Math.random()];

                var mesh = new xeogl.Mesh(model, {
                    id: model.id + &quot;#&quot; + object.id,
                    geometry: xeoGeometry,
                    material: material,
                    pickable: true
                });

                model.addChild(mesh);
                model._addComponent(mesh);
            }
        };
    })();

    function loadFile(url, ok, err) {
        var request = new XMLHttpRequest();
        request.open(&#x27;GET&#x27;, url, true);
        request.addEventListener(&#x27;load&#x27;, function (event) {
            var response = event.target.response;
            if (this.status === 200) {
                if (ok) {
                    ok(response);
                }
            } else if (this.status === 0) {
                // Some browsers return HTTP Status 0 when using non-http protocol
                // e.g. &#x27;file://&#x27; or &#x27;data://&#x27;. Handle as success.
                console.warn(&#x27;loadFile: HTTP Status 0 received.&#x27;);
                if (ok) {
                    ok(response);
                }
            } else {
                if (err) {
                    err(event);
                }
            }
        }, false);

        request.addEventListener(&#x27;error&#x27;, function (event) {
            if (err) {
                err(event);
            }
        }, false);
        request.send(null);
    }
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
