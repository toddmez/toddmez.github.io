<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/lindsay/xeolabs/xeogl-next/xeogl/examples/js/controls/BIMClipControl.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">

    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
            
                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
            
                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
            
                <li><a href="../classes/Annotation.html">Annotation</a></li>
            
                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
            
                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
            
                <li><a href="../classes/BIMServerModel.html">BIMServerModel</a></li>
            
                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
            
                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
            
                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
            
                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
            
                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
            
                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/Clip.html">Clip</a></li>
            
                <li><a href="../classes/ClipControl.html">ClipControl</a></li>
            
                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
            
                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
            
                <li><a href="../classes/Curve.html">Curve</a></li>
            
                <li><a href="../classes/CustomProjection.html">CustomProjection</a></li>
            
                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
            
                <li><a href="../classes/DirLight.html">DirLight</a></li>
            
                <li><a href="../classes/EdgeMaterial.html">EdgeMaterial</a></li>
            
                <li><a href="../classes/EmphasisMaterial.html">EmphasisMaterial</a></li>
            
                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
            
                <li><a href="../classes/Frustum.html">Frustum</a></li>
            
                <li><a href="../classes/Geometry.html">Geometry</a></li>
            
                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
            
                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/LambertMaterial.html">LambertMaterial</a></li>
            
                <li><a href="../classes/LightMap.html">LightMap</a></li>
            
                <li><a href="../classes/Material.html">Material</a></li>
            
                <li><a href="../classes/Mesh.html">Mesh</a></li>
            
                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
            
                <li><a href="../classes/Model.html">Model</a></li>
            
                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
            
                <li><a href="../classes/Ortho.html">Ortho</a></li>
            
                <li><a href="../classes/OutlineMaterial.html">OutlineMaterial</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
            
                <li><a href="../classes/Perspective.html">Perspective</a></li>
            
                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
            
                <li><a href="../classes/Pin.html">Pin</a></li>
            
                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
            
                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
            
                <li><a href="../classes/PointLight.html">PointLight</a></li>
            
                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
            
                <li><a href="../classes/ReflectionMap.html">ReflectionMap</a></li>
            
                <li><a href="../classes/Scene.html">Scene</a></li>
            
                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
            
                <li><a href="../classes/Shadow.html">Shadow</a></li>
            
                <li><a href="../classes/Skybox.html">Skybox</a></li>
            
                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
            
                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
            
                <li><a href="../classes/Spinner.html">Spinner</a></li>
            
                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
            
                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
            
                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
            
                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
            
                <li><a href="../classes/STLModel.html">STLModel</a></li>
            
                <li><a href="../classes/Story.html">Story</a></li>
            
                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
            
                <li><a href="../classes/TestModel.html">TestModel</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
            
                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
            
                <li><a href="../classes/Viewport.html">Viewport</a></li>
            
                <li><a href="../classes/xeogl.xeogl.html">xeogl.xeogl</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..//modules/animation.html">animation</a></li>
            
                <li><a href="..//modules/annotations.html">annotations</a></li>
            
                <li><a href="..//modules/camera.html">camera</a></li>
            
                <li><a href="..//modules/canvas.html">canvas</a></li>
            
                <li><a href="..//modules/clipping.html">clipping</a></li>
            
                <li><a href="..//modules/controls.html">controls</a></li>
            
                <li><a href="..//modules/curves.html">curves</a></li>
            
                <li><a href="..//modules/effects.html">effects</a></li>
            
                <li><a href="..//modules/generation.html">generation</a></li>
            
                <li><a href="..//modules/geometry.html">geometry</a></li>
            
                <li><a href="..//modules/helpers.html">helpers</a></li>
            
                <li><a href="..//modules/input.html">input</a></li>
            
                <li><a href="..//modules/lighting.html">lighting</a></li>
            
                <li><a href="..//modules/materials.html">materials</a></li>
            
                <li><a href="..//modules/math.html">math</a></li>
            
                <li><a href="..//modules/meshes.html">meshes</a></li>
            
                <li><a href="..//modules/models.html">models</a></li>
            
                <li><a href="..//modules/objects.html">objects</a></li>
            
                <li><a href="..//modules/rendering.html">rendering</a></li>
            
                <li><a href="..//modules/scene.html">scene</a></li>
            
                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
            
                <li><a href="..//modules/stories.html">stories</a></li>
            
                <li><a href="..//modules/xeogl.html">xeogl</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
        <!--Show:-->
        <!--<label for="api-show-inherited">-->
            <!--<input type="checkbox" id="api-show-inherited" checked>-->
            <!--Inherited-->
        <!--</label>-->

        <!--<label for="api-show-protected">-->
            <!--<input type="checkbox" id="api-show-protected">-->
            <!--Protected-->
        <!--</label>-->

        <!--<label for="api-show-private">-->
            <!--<input type="checkbox" id="api-show-private">-->
            <!--Private-->
        <!--</label>-->
        <!--<label for="api-show-deprecated">-->
            <!--<input type="checkbox" id="api-show-deprecated">-->
            <!--Deprecated-->
        <!--</label>-->

    <!--</div>-->


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/lindsay/xeolabs/xeogl-next/xeogl/examples/js/controls/BIMClipControl.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**

 Positions and orients clipping planes with mouse and touch input.

 Inspired by the AutoDesk Forge gizmo.

 @param scene
 @constructor

 */
var BIMClipControl = function (scene) {

    var self = this;
    var math = xeogl.math;
    var camera = scene.camera;
    var canvas = scene.canvas.canvas;

    var active = false;
    var solid = false; // Whether to render clip plane with a fill color.
    var visible = false; // Whether or not the gizmo is visible.
    var clipStartDir = math.vec3(); // Saves direction of clip plane when we start dragging a gizmo arrow or ring.
    var clipPos = math.vec3(); // Holds the current position of the center of the clip plane.
    var clip = null;

    var group = new xeogl.Group(scene, {
        scale: [1, 1, 1],
        quaternion: [0, 0, 0, 1],
        position: [0, 0, 0]
    });

    var displayMeshes = null; // Map of xeogl.Mesh&#x27;s that are always visible when gizmo visible
    var affordanceMeshes = null; // Map of xeogl.Mesh&#x27;s that are shown momentarily to give &quot;affordance&quot; when interacting with the gizmo

    const INVISIBLE = true;
    const PICKABLE_VISIBLE = false;

    /**
     Indicates whether this BIMClipControl is active or not.

     @param {Boolean} value True to activate.
     */
    this.setActive = function (value) {
        value = value !== false;
        if (value === active) {
            return;
        }
        active = value;
    };

    /**
     Sets the {{#crossLink &quot;Clip&quot;}}{{/crossLink}} controlled by this BIMClipControl.

     @param {String} clipId ID of clip plane within the scene
     */
    this.setClip = (function () {
        var zeroVec = new Float32Array([0, 0, -1]);
        var quat = new Float32Array(4);
        return function (clipId) {
            var clips = scene.types[&quot;xeogl.Clip&quot;];
            var newClip = clips ? clips[clipId] : null;
            if (newClip) {
                this._setVisible(true);
                clip = newClip;
                // Save initial clip plane pos and direction,
                // Set gizmo&#x27;s current direction and position
                clipStartDir.set(clip.dir);
                math.vec3PairToQuaternion(zeroVec, clipStartDir, quat);
                group.quaternion = quat;
                group.position = clipPos;
                clipPos.set(clip.pos);
                clip.on(&quot;destroyed&quot;, function () {
                    clip = null;
                });
            } else {
                clip = false;
                this._setVisible(false);
            }
        };
    })();

    this._setVisible = function (value) {
        value = !!value;
        if (visible === value) {
            return;
        }
        visible = value;
        var id;
        for (id in displayMeshes) {
            if (displayMeshes.hasOwnProperty(id)) {
                displayMeshes[id].visible = value;
            }
        }
        if (!value) { // Affordance meshes are not initially visible
            for (id in affordanceMeshes) {
                if (affordanceMeshes.hasOwnProperty(id)) {
                    affordanceMeshes[id].visible = value;
                }
            }
        }
        return this;
    };

    this._initObjects = function () {

        var ringRadius = 1;
        var axisLength = ringRadius * 0.6;
        var tube = 0.01;
        var arrowRadius = 0.06;
        var arrowHeight = arrowRadius * 3;
        var geometries = {
            arrowHead: new xeogl.CylinderGeometry(scene, {
                radiusTop: 0.001,
                radiusBottom: arrowRadius,
                height: arrowHeight,
                radialSegments: 16,
                heightSegments: 1,
                openEnded: false
            }),
            arc: new xeogl.TorusGeometry(scene, {
                radius: ringRadius,
                tube: tube,
                radialSegments: 64,
                tubeSegments: 14,
                arc: (Math.PI * 2.0) / 4.0
            }),
            ring: new xeogl.TorusGeometry(scene, {
                radius: ringRadius,
                tube: tube,
                radialSegments: 64,
                tubeSegments: 8,
                arc: (Math.PI * 2.0)
            }),
            arcPickable: new xeogl.TorusGeometry(scene, {
                radius: ringRadius,
                tube: 0.06,
                radialSegments: 64,
                tubeSegments: 14,
                arc: (Math.PI * 2.0) / 4.0
            }),
            axis: new xeogl.CylinderGeometry(scene, {
                radiusTop: tube,
                radiusBottom: tube,
                height: axisLength,
                radialSegments: 20,
                heightSegments: 1,
                openEnded: false
            }),
            axisPickable: new xeogl.CylinderGeometry(scene, {
                radiusTop: 0.06,
                radiusBottom: 0.06,
                height: axisLength,
                radialSegments: 20,
                heightSegments: 1,
                openEnded: false
            })
        };
        var materials = {
            invisible: new xeogl.LambertMaterial(scene, {
                color: [0, 0, 0],
                emissive: [1, 1, 1],
                alpha: 0 // Invisible
            }),
            affordanceHighlight: new xeogl.EmphasisMaterial(scene, {
                edges: false,
                edgeColor: [1, 1, 1],
                fill: true,
                fillColor: [1, 1, 0],
                fillAlpha: 1,
                vertices: false
            })
        };

        // Entities that are always visible while the gizmo is visible
        // We can show/hide these as a batch when showing/hiding the gizmo

        displayMeshes = {

            // yawHandle: new xeogl.Mesh(scene, { // Red quarter-hoop
            //     geometry: geometries.arc,
            //     // material: new xeogl.LambertMaterial(scene, {
            //     //     color: [1, 0, 0],
            //     //     emissive: [1, 0, 0],
            //     //     alpha: 1
            //     // }),
            //     highlighted: true,
            //     highlightMaterial: new xeogl.EmphasisMaterial(scene, {
            //         edges: false,
            //         edgeColor: [1, 1, 1],
            //         fill: true,
            //         fillColor: [1, 0, 0],
            //         fillAlpha: 0.5,
            //         vertices: false
            //     }),
            //     rotation: [90, -90, 0],
            //     collidable: false,
            //     clippable: false,
            //     backfaces: true,
            //     visible: INVISIBLE,
            //     pickable: false
            // }),

            // yawHandlePickable: new xeogl.Mesh(scene, { // Thick pickable invisible quarter-hoop wrapping the red quarter hoop
            //     geometry: geometries.arcPickable,
            //     material: materials.invisible,
            //     rotation: [90, -45, 0],
            //     collidable: false,
            //     clippable: false,
            //     visible: PICKABLE_VISIBLE,
            //     pickable: true
            // }),

            // pitchHandle: new xeogl.Mesh(scene, { // Blue quarter-hoop
            //     geometry: geometries.arc,
            //     // material: new xeogl.LambertMaterial(scene, {
            //     //     color: [0, 0, 1],
            //     //     emissive: [0, 0, 1],
            //     //     //emissive: [1, 0, 1],
            //     //     alpha: 1
            //     // }),
            //     highlighted: true,
            //     highlightMaterial: new xeogl.EmphasisMaterial(scene, {
            //         edges: false,
            //         edgeColor: [1, 1, 1],
            //         fill: true,
            //         fillColor: [0, 0, 1],
            //         fillAlpha: 0.5,
            //         vertices: false
            //     }),
            //     rotation: [135, 90, 0],
            //     collidable: false,
            //     clippable: false,
            //     backfaces: true,
            //     visible: INVISIBLE,
            //     pickable: false
            // })
            //,

            // pitchHandlePickable: new xeogl.Mesh(scene, { // Invisible quarter-hoop wrapping the blue quarter-hoop
            //     geometry: geometries.arcPickable,
            //     material: materials.invisible,
            //     rotation: [135, 90, 0],
            //     collidable: false,
            //     clippable: false,
            //     visible: PICKABLE_VISIBLE,
            //     pickable: true
            // }),

            axis: new xeogl.Group(scene, {
                rotation: [90, 0, 0],
                children: [
                    new xeogl.Mesh(scene, { // Blue shaft
                        geometry: geometries.axis,
                        material: new xeogl.LambertMaterial(scene, {
                            color: [0, 0, 1],
                            emissive: [0, 0, 1],
                            alpha: 1
                        }),
                        highlighted: true,
                        highlightMaterial: new xeogl.EmphasisMaterial(scene, {
                            edges: false,
                            fill: true,
                            fillColor: [0, 0, 1],
                            fillAlpha: 0.5,
                            vertices: false
                        }),
                        position: [axisLength / 2, 0, 0],
                        clippable: false,
                        invisible: false,
                        collidable: false,
                        visible: INVISIBLE,
                        pickable: false
                    })
                ]
            }),


            //
            // axisPickable: new xeogl.Mesh(scene, { // Blue shaft
            //     geometry: geometries.axisPickable,
            //     material: materials.invisible,
            //     position: [0, axisLength / 2, 0],
            //     rotation: [90, 0, 0],
            //     clippable: false,
            //     invisible: false,
            //     collidable: false,
            //     visible: PICKABLE_VISIBLE,
            //     pickable: true
            // }),
            //
            // arrow: new xeogl.Mesh(scene, { // Blue arrow
            //     geometry: geometries.arrowHead,
            //     material: new xeogl.LambertMaterial(scene, {
            //         color: [0, 0, 1],
            //         emissive: [0, 0, 1],
            //         alpha: 1
            //     }),
            //     highlighted: true,
            //     highlightMaterial: new xeogl.EmphasisMaterial(scene, {
            //         edges: false,
            //         fill: true,
            //         fillColor: [0, 0, 1],
            //         fillAlpha: 0.5,
            //         vertices: false
            //     }),
            //     position: [0, axisLength + (arrowHeight / 2)],
            //     rotation: [90, 0, 0],
            //     invisible: true,
            //     collidable: false,
            //     clippable: false,
            //     visible: INVISIBLE,
            //     pickable: true
            // }),
            //
            ball: new xeogl.Mesh(scene, {
                geometry: new xeogl.SphereGeometry(scene, {
                    radius: 0.05
                }),
                material: new xeogl.LambertMaterial(scene, {
                    color: [0, 0, 1],
                    emissive: [0, 0, 1],
                    alpha: 1
                }),
                //   position: [0, 0, ringRadius],
                highlighted: true,
                highlightMaterial: new xeogl.EmphasisMaterial(scene, {
                    edges: false,
                    fill: true,
                    fillColor: [0, 0, 1],
                    fillAlpha: 0.5,
                    vertices: false
                }),
                collidable: false,
                clippable: false,
                visible: INVISIBLE,
                pickable: false
            })
        };

        // Entities that appear momentarily during certain interactions to give &quot;affordance&quot;. We keep these
        // in their own map so they don&#x27;t all get shown when we show the BIMClipControl.

        affordanceMeshes = {

            // yawRing: new xeogl.Mesh(scene, { // Yellow ring about X-axis
            //     geometry: geometries.ring,
            //     material: new xeogl.LambertMaterial(scene, {
            //         color: [1, 1, 0],
            //         emissive: [1, 1, 0],
            //         alpha: 1
            //     }),
            //     highlighted: true,
            //     highlightMaterial: materials.affordanceHighlight,
            //     rotation: [-90, 0, 0],
            //     collidable: false,
            //     clippable: false,
            //     visible: INVISIBLE,
            //     pickable: false
            // }),
            //
            // pitchRing: new xeogl.Mesh(scene, { // Yellow ring about Y-axis
            //     geometry: geometries.ring,
            //     material: new xeogl.LambertMaterial(scene, {
            //         color: [1, 1, 0],
            //         emissive: [1, 1, 0],
            //         alpha: 1
            //     }),
            //     highlighted: true,
            //     highlightMaterial: materials.affordanceHighlight,
            //     rotation: [270, 90, 0],
            //     collidable: false,
            //     clippable: false,
            //     visible: INVISIBLE,
            //     pickable: false
            // })
            //,

            // axis: new xeogl.Mesh(scene, { // Blue shaft
            //     geometry: geometries.axis,
            //     material: new xeogl.LambertMaterial(scene, {
            //         color: [1, 1, 0],
            //         emissive: [1, 1, 0],
            //         alpha: 1
            //     }),
            //     highlighted: true,
            //     highlightMaterial: materials.affordanceHighlight,
            //     position: [0, axisLength / 2, 0],
            //     rotation: [90, 0, 0],
            //     clippable: false,
            //     collidable: false,
            //     visible: INVISIBLE,
            //     pickable: false
            // }),
            //
            // arrow: new xeogl.Mesh(scene, { // Blue arrow
            //     geometry: geometries.arrowHead,
            //     material: new xeogl.LambertMaterial(scene, {
            //         color: [1, 1, 0],
            //         emissive: [1, 1, 0],
            //         alpha: 1
            //     }),
            //     highlighted: true,
            //     highlightMaterial: materials.affordanceHighlight,
            //     position: [0, axisLength + (arrowHeight / 2)],
            //     rotation: [90, 0, 0],
            //     collidable: false,
            //     clippable: false,
            //     visible: INVISIBLE,
            //     pickable: false
            // }),
            //
            // ball: new xeogl.Mesh(scene, {
            //     geometry: new xeogl.SphereGeometry(scene, {
            //         radius: 0.055
            //     }),
            //     material: new xeogl.LambertMaterial(scene, {
            //         color: [1, 1, 0],
            //         emissive: [1, 1, 0],
            //         alpha: 1
            //     }),
            //     position: [0, 0, ringRadius],
            //     highlighted: true,
            //     highlightMaterial: materials.affordanceHighlight,
            //     collidable: false,
            //     clippable: false,
            //     visible: INVISIBLE,
            //     pickable: false
            // })
        };
    };

    this._initEvents = function () {

        var over = false;

        const DRAG_ACTIONS = {
            none: -1, // Do nothing
            pan: 2, // Move along axis
            pitch: 3, // Rotate about horizontal local axis
            yaw: 4 // Rotate about vertical local axis
        };

        var nextDragAction = null; // As we hover over an arrow or ring, this is the action we would do if we then dragged it
        var dragAction = null; // Action we&#x27;re doing while dragging an arrow or ring

        var dragClipPosOrigin = math.vec3();
        var dragCanvasOrigin = math.vec2();
        var dragCanvasVec = math.vec2();

        var xLocalAxis = math.vec3([1, 0, 0]);
        var yLocalAxis = math.vec3([0, 1, 0]);
        var zLocalAxis = math.vec3([0, 0, -1]);

        var rotateWorldVec = math.vec3();
        var panWorldVec = math.vec3();
        var panCanvasVec = math.vec2();

        // var zUpWorldAxis = [
        //     1, 0, 0, // Right
        //     0, 0, 1, // Up
        //     0,-1, 0  // Forward
        // ];

        // var yUpWorldAxis = [
        //     1, 0, 0,    // Right
        //     0, 1, 0,    // Up
        //     0, 0,-1     // Forward
        // ];

        canvas.oncontextmenu = function (e) {
            e.preventDefault();
        };

        var shownEntities = []; // Mesh we&#x27;re currently showing for affordance (ie. big arrow head or complete ring on mouse over)
        var lenShownEntities = 0;

        var hiddenEntities = []; // Mesh we&#x27;re currently showing for affordance (ie. big arrow head or complete ring on mouse over)
        var lenHiddenEntities = 0;

        function showMesh(mesh) {
            // FIXME
            return;
            mesh.visible = true;
            shownEntities[lenShownEntities++] = mesh;
        }

        function hideMesh(mesh) {
            // FIXME
            return;
            mesh.visible = false;
            hiddenEntities[lenHiddenEntities++] = mesh;
        }

        function restoreEntities() {
            for (var i = 0; i &lt; lenShownEntities; i++) {
                shownEntities[i].visible = false;
            }
            lenShownEntities = 0;
            for (var i = 0; i &lt; lenHiddenEntities; i++) {
                hiddenEntities[i].visible = true;
            }
            lenHiddenEntities = 0;
        }

        var getClickCoordsWithinElement = (function () {
            var coords = new Float32Array(2);
            return function (event) {
                if (!event) {
                    event = window.event;
                    coords[0] = event.x;
                    coords[a] = event.y;
                } else {
                    var element = event.target;
                    var totalOffsetLeft = 0;
                    var totalOffsetTop = 0;
                    while (element.offsetParent) {
                        totalOffsetLeft += element.offsetLeft;
                        totalOffsetTop += element.offsetTop;
                        element = element.offsetParent;
                    }
                    coords[0] = event.pageX - totalOffsetLeft;
                    coords[1] = event.pageY - totalOffsetTop;
                }
                return coords;
            };
        })();

        var localToWorldVec = (function () {
            var mat = math.mat4();
            return function (localVec, worldVec) {

                // FIXME
                //math.quaternionToMat4(gizmoQuaternion.xyzw, mat);
                math.transformVec3(mat, localVec, worldVec);
                return worldVec;
            };
        })();

        var worldToCanvasVec = (function () {
            var tempVec4a = math.vec4([0, 0, 0, 1]);
            var tempVec4b = math.vec4();
            var tempVec4c = math.vec4();
            return function (worldVec, canvasVec) {
                tempVec4a.set(worldVec);
                math.transformPoint4(camera.matrix, tempVec4a, tempVec4b);
                math.transformPoint4(camera.projMatrix, tempVec4b, tempVec4c);
                var aabb = scene.canvas.boundary;
                canvasVec[0] = Math.floor((1 + tempVec4c[0] / tempVec4c[3]) * aabb[2] / 2);
                canvasVec[1] = Math.floor((1 - tempVec4c[1] / tempVec4c[3]) * aabb[3] / 2);
                canvasVec[0] -= aabb[2] / 2;
                canvasVec[1] -= aabb[3] / 2;
                return canvasVec;
            };
        })();

        // Make canvas size remain constant

        (function () {

            var tempVec3a = math.vec3([0, 0, 0]);
            var distDirty = true;
            var lastDist = -1;

            camera.on(&quot;viewPatrix&quot;, function () {
                distDirty = true;
            });

            camera.on(&quot;projMatrix&quot;, function () {
                distDirty = true;
            });

            scene.on(&quot;tick&quot;, function () {
                // if (distDirty) {
                //     var dist = Math.abs(math.lenVec3(math.subVec3(camera.eye, clipPos, tempVec3a)));
                //     if (dist != lastDist) {
                //         var scale = dist / 6;
                //         gizmoScale.xyz = [scale, scale, scale];
                //         lastDist = dist;
                //     }
                //     distDirty = false;
                // }
            });

        })();

        (function () {

            var lastX;
            var lastY;
            var xDelta = 0;
            var yDelta = 0;
            var down = false;

            var mouseDownLeft;
            var mouseDownMiddle;
            var mouseDownRight;

            canvas.addEventListener(&quot;mouseenter&quot;, function () {
                if (!active) {
                    return;
                }
                over = true;
                xDelta = 0;
                yDelta = 0;
            });

            canvas.addEventListener(&quot;mouseleave&quot;, function () {
                if (!active) {
                    return;
                }
                over = false;
                xDelta = 0;
                yDelta = 0;
            });

            canvas.addEventListener(&quot;mousemove&quot;, function (e) {
                return;
                if (!active) {
                    return;
                }
                if (!over) {
                    return;
                }
                var coords = getClickCoordsWithinElement(e);
                if (!down) {

                    var hit = scene.pick({
                        canvasPos: coords,
                        include: [
                            displayMeshes.axisPickable.id,
                            displayMeshes.arrow.id,
                            displayMeshes.pitchHandlePickable.id,
                            displayMeshes.yawHandlePickable.id
                        ]
                    });

                    restoreEntities();

                    if (hit) {
                        var id = hit.mesh.id;
                        switch (id) {
                            case displayMeshes.axisPickable.id:
                            case displayMeshes.arrow.id:
                                hideMesh(displayMeshes.axis);
                                hideMesh(displayMeshes.arrow);
                                showMesh(affordanceMeshes.axis);
                                showMesh(affordanceMeshes.arrow);
                                localToWorldVec(zLocalAxis, panWorldVec);
                                worldToCanvasVec(panWorldVec, panCanvasVec);
                                nextDragAction = DRAG_ACTIONS.pan;
                                break;

                            case displayMeshes.pitchHandlePickable.id:
                                hideMesh(displayMeshes.pitchHandle);
                                hideMesh(displayMeshes.ball);
                                showMesh(affordanceMeshes.pitchRing);
                                showMesh(affordanceMeshes.ball);
                                localToWorldVec(xLocalAxis, rotateWorldVec);
                                nextDragAction = DRAG_ACTIONS.pitch;
                                break;

                            case displayMeshes.yawHandlePickable.id:
                                hideMesh(displayMeshes.yawHandle);
                                hideMesh(displayMeshes.ball);
                                showMesh(affordanceMeshes.yawRing);
                                showMesh(affordanceMeshes.ball);
                                localToWorldVec(yLocalAxis, rotateWorldVec);
                                nextDragAction = DRAG_ACTIONS.yaw;
                                break;

                            default:
                                nextDragAction = DRAG_ACTIONS.none;
                                return;
                        }
                    } else {
                        nextDragAction = DRAG_ACTIONS.none;
                    }
                    return;
                }

                var x = coords[0];
                var y = coords[1];

                xDelta += (x - lastX) * 0.1;
                yDelta += (y - lastY) * 0.1;

                lastX = x;
                lastY = y;

                dragCanvasVec[0] = coords[0] - dragCanvasOrigin[0];
                dragCanvasVec[1] = coords[1] - dragCanvasOrigin[1];
            });

            canvas.addEventListener(&quot;mousedown&quot;, function (e) {
                if (!active) {
                    return;
                }
                if (!over) {
                    return;
                }
                switch (e.which) {
                    case 1: // Left button
                        mouseDownLeft = true;
                        down = true;
                        xDelta = 0;
                        yDelta = 0;
                        var coords = getClickCoordsWithinElement(e);
                        lastX = coords[0];
                        lastY = coords[1];
                        dragAction = nextDragAction;
                        dragCanvasOrigin[0] = coords[0];
                        dragCanvasOrigin[1] = coords[1];
                        dragClipPosOrigin.set(clipPos);
                        break;
                    default:
                        break;
                }
            });

            canvas.addEventListener(&quot;mouseup&quot;, function (e) {
                restoreEntities();
                if (!active) {
                    return;
                }
                switch (e.which) {
                    case 1: // Left button
                        mouseDownLeft = false;
                        break;
                    case 2: // Middle/both buttons
                        mouseDownMiddle = false;
                        break;
                    case 3: // Right button
                        mouseDownRight = false;
                        break;
                    default:
                        break;
                }
                down = false;
                xDelta = 0;
                yDelta = 0;
            });

            var pan = function (inc, f) {
                clipPos[0] = dragClipPosOrigin[0] + inc[0] * f;
                clipPos[1] = dragClipPosOrigin[1] + inc[1] * f;
                clipPos[2] = dragClipPosOrigin[2] + inc[2] * f;
                group.position = clipPos;
                if (clip) {
                    clip.pos = clipPos;
                }
            };
        })();
    };

    this._initObjects();
    this._initEvents();
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
