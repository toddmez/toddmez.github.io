<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/home/lindsay/xeolabs/xeogl-next/xeogl/src/objects/mesh.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">

    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
            
                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
            
                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
            
                <li><a href="../classes/Annotation.html">Annotation</a></li>
            
                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
            
                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
            
                <li><a href="../classes/BIMServerModel.html">BIMServerModel</a></li>
            
                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
            
                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
            
                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
            
                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
            
                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
            
                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/Clip.html">Clip</a></li>
            
                <li><a href="../classes/ClipControl.html">ClipControl</a></li>
            
                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
            
                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
            
                <li><a href="../classes/Curve.html">Curve</a></li>
            
                <li><a href="../classes/CustomProjection.html">CustomProjection</a></li>
            
                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
            
                <li><a href="../classes/DirLight.html">DirLight</a></li>
            
                <li><a href="../classes/EdgeMaterial.html">EdgeMaterial</a></li>
            
                <li><a href="../classes/EmphasisMaterial.html">EmphasisMaterial</a></li>
            
                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
            
                <li><a href="../classes/Frustum.html">Frustum</a></li>
            
                <li><a href="../classes/Geometry.html">Geometry</a></li>
            
                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
            
                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/LambertMaterial.html">LambertMaterial</a></li>
            
                <li><a href="../classes/LightMap.html">LightMap</a></li>
            
                <li><a href="../classes/Material.html">Material</a></li>
            
                <li><a href="../classes/Mesh.html">Mesh</a></li>
            
                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
            
                <li><a href="../classes/Model.html">Model</a></li>
            
                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
            
                <li><a href="../classes/Ortho.html">Ortho</a></li>
            
                <li><a href="../classes/OutlineMaterial.html">OutlineMaterial</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
            
                <li><a href="../classes/Perspective.html">Perspective</a></li>
            
                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
            
                <li><a href="../classes/Pin.html">Pin</a></li>
            
                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
            
                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
            
                <li><a href="../classes/PointLight.html">PointLight</a></li>
            
                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
            
                <li><a href="../classes/ReflectionMap.html">ReflectionMap</a></li>
            
                <li><a href="../classes/Scene.html">Scene</a></li>
            
                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
            
                <li><a href="../classes/Shadow.html">Shadow</a></li>
            
                <li><a href="../classes/Skybox.html">Skybox</a></li>
            
                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
            
                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
            
                <li><a href="../classes/Spinner.html">Spinner</a></li>
            
                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
            
                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
            
                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
            
                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
            
                <li><a href="../classes/STLModel.html">STLModel</a></li>
            
                <li><a href="../classes/Story.html">Story</a></li>
            
                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
            
                <li><a href="../classes/TestModel.html">TestModel</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
            
                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
            
                <li><a href="../classes/Viewport.html">Viewport</a></li>
            
                <li><a href="../classes/xeogl.xeogl.html">xeogl.xeogl</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..//modules/animation.html">animation</a></li>
            
                <li><a href="..//modules/annotations.html">annotations</a></li>
            
                <li><a href="..//modules/camera.html">camera</a></li>
            
                <li><a href="..//modules/canvas.html">canvas</a></li>
            
                <li><a href="..//modules/clipping.html">clipping</a></li>
            
                <li><a href="..//modules/controls.html">controls</a></li>
            
                <li><a href="..//modules/curves.html">curves</a></li>
            
                <li><a href="..//modules/effects.html">effects</a></li>
            
                <li><a href="..//modules/generation.html">generation</a></li>
            
                <li><a href="..//modules/geometry.html">geometry</a></li>
            
                <li><a href="..//modules/helpers.html">helpers</a></li>
            
                <li><a href="..//modules/input.html">input</a></li>
            
                <li><a href="..//modules/lighting.html">lighting</a></li>
            
                <li><a href="..//modules/materials.html">materials</a></li>
            
                <li><a href="..//modules/math.html">math</a></li>
            
                <li><a href="..//modules/meshes.html">meshes</a></li>
            
                <li><a href="..//modules/models.html">models</a></li>
            
                <li><a href="..//modules/objects.html">objects</a></li>
            
                <li><a href="..//modules/rendering.html">rendering</a></li>
            
                <li><a href="..//modules/scene.html">scene</a></li>
            
                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
            
                <li><a href="..//modules/stories.html">stories</a></li>
            
                <li><a href="..//modules/xeogl.html">xeogl</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
        <!--Show:-->
        <!--<label for="api-show-inherited">-->
            <!--<input type="checkbox" id="api-show-inherited" checked>-->
            <!--Inherited-->
        <!--</label>-->

        <!--<label for="api-show-protected">-->
            <!--<input type="checkbox" id="api-show-protected">-->
            <!--Protected-->
        <!--</label>-->

        <!--<label for="api-show-private">-->
            <!--<input type="checkbox" id="api-show-private">-->
            <!--Private-->
        <!--</label>-->
        <!--<label for="api-show-deprecated">-->
            <!--<input type="checkbox" id="api-show-deprecated">-->
            <!--Deprecated-->
        <!--</label>-->

    <!--</div>-->


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/lindsay/xeolabs/xeogl-next/xeogl/src/objects/mesh.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 A **Mesh** is an {{#crossLink &quot;Object&quot;}}{{/crossLink}} that represents a drawable 3D primitive.

 ## Overview

 * A Mesh represents a WebGL draw call.
 * Each Mesh has six components: {{#crossLink &quot;Geometry&quot;}}{{/crossLink}} for shape, {{#crossLink &quot;Material&quot;}}{{/crossLink}}
 for normal rendered appearance, three {{#crossLink &quot;EmphasisMaterial&quot;}}EmphasisMaterials{{/crossLink}} for ghosted, highlighted and selected effects,
 and {{#crossLink &quot;EdgeMaterial&quot;}}{{/crossLink}} for rendering emphasised edges.
 * By default, Meshes in the same Scene share the same global scene flyweight instances of those components among themselves. The default
 component instances are provided by the {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s {{#crossLink &quot;Scene/geometry:property&quot;}}{{/crossLink}},
 {{#crossLink &quot;Scene/material:property&quot;}}{{/crossLink}}, {{#crossLink &quot;Scene/ghostMaterial:property&quot;}}{{/crossLink}}, {{#crossLink &quot;Scene/highlightMaterial:property&quot;}}{{/crossLink}},
 {{#crossLink &quot;Scene/selectedMaterial:property&quot;}}{{/crossLink}} and {{#crossLink &quot;Scene/edgeMaterial:property&quot;}}{{/crossLink}} properties.
 * A Mesh with all defaults is a white unit-sized box centered at the World-space origin.
 * Customize your Meshes by attaching your own instances of those component types, to override the defaults as needed.
 * For best performance, reuse as many of the same component instances among your Meshes as possible.
 * Use {{#crossLink &quot;Group&quot;}}Group{{/crossLink}} components to organize Meshes into hierarchies, if required.

 This page covers functionality specific to the Mesh component, while {{#crossLink &quot;Object&quot;}}{{/crossLink}} covers generic
 functionality inherited from the base class.

 ## Usage

 * [Creating a Mesh](#creating-a-mesh)
 * [Creating hierarchies](#creating-hierarchies)
 * [Controlling visibility](#controlling-visibility)
 * [Controlling clipping](#controlling-clipping)
 * [Controlling rendering order](#controlling-rendering-order)
 * [Geometry](#geometry)
 * [Material](#material)
 * [Transforming](#transforming)
 * [Ghosting](#ghosting)
 * [Highlighting](#highlighting)
 * [Outlining](#outlining)
 * [Local-space boundary](#local-space-boundary)
 * [World-space boundary](#world-space-boundary)
 * [Skyboxing](#skyboxing)
 * [Billboarding](#billboarding)
 * [Shadows](#shadows) TODO

 ### Creating a Mesh

 Creating a minimal Mesh that has all the default components:

 &lt;img src=&quot;../../assets/images/screenshots/Scene/defaultMesh.png&quot;&gt;&lt;/img&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh(); // A white unit-sized box centered at the World-space origin
 &#x60;&#x60;&#x60;&#x60;

 Since our Mesh has all the default components, we can get those off either the Mesh or its Scene:

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.material.diffuse = [1.0, 0.0, 0.0];           // This is the same Material component...
 mesh.scene.material.diffuse  = [1.0, 0.0, 0.0];    // ...as this one.
 &#x60;&#x60;&#x60;&#x60;

 In practice, we would provide (at least) our own Geometry and Material for the Mesh:

 &lt;a href=&quot;../../examples/#geometry_primitives_teapot&quot;&gt;&lt;img src=&quot;../../assets/images/screenshots/Scene/teapot.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
     geometry: new xeogl.TeapotGeometry(),
     material: new xeogl.MetallicMaterial({
         baseColor: [1.0, 1.0, 1.0]
     })
 });
 &#x60;&#x60;&#x60;&#x60;

 ### Creating hierarchies

 In xeogl we represent an object hierarchy as a tree of {{#crossLink &quot;Object&quot;}}Objects{{/crossLink}} in which
 the leaf Objects are Meshes. In an Object tree, an operation on an Object is recursively applied to sub-Objects, down
 to the Meshes at the leaves.

 See {{#crossLink &quot;Object&quot;}}{{/crossLink}} for information on organizing Meshes hierarchically.

 ### Controlling visibility

 Show or hide a Mesh by setting its {{#crossLink &quot;Mesh/visible:property&quot;}}{{/crossLink}} property:

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.visible = false; // Hide
 mesh.visible = true; // Show (default)
 &#x60;&#x60;&#x60;&#x60;

 This property is inherited from {{#crossLink &quot;Object/visible:property&quot;}}Object{{/crossLink}}.

 ### Controlling clipping

 By default, a Mesh will be clipped by the
 Scene&#x27;s {{#crossLink &quot;Scene/clips:property&quot;}}clipping planes{{/crossLink}}.

 Make a Mesh unclippable by setting its {{#crossLink &quot;Mesh/clippable:property&quot;}}{{/crossLink}} property false:

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.clippable = false; // Default is true
 &#x60;&#x60;&#x60;&#x60;

 ### Controlling rendering order

 Control the order in which a Mesh is rendered relative to others by setting its {{#crossLink &quot;Mesh/layer:property&quot;}}{{/crossLink}}
 property. You would normally do this when you need to ensure that transparent Meshes are rendered in back-to-front order for correct alpha blending.

 Assigning our Mesh to layer 0 (all Meshes are in layer 0 by default):

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.layer = 0;
 &#x60;&#x60;&#x60;&#x60;

 Create another Mesh in a higher layer, that will get rendered after layer 0:

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh2 = new xeogl.Mesh({
     geometry: new xeogl.Sphere(),
     layer: 1
 });
 &#x60;&#x60;&#x60;&#x60;

 ### Geometry

 A Mesh has a {{#crossLink &quot;Geometry&quot;}}{{/crossLink}} which describes its shape. When we don&#x27;t provide a Geometry,
 a Mesh will automatically get its {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s {{#crossLink &quot;Scene/geometry:property&quot;}}{{/crossLink}} by default.

 Creating a Mesh with its own Geometry:

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
     geometry: new xeogl.TeapotGeometry()
 });
 &#x60;&#x60;&#x60;&#x60;

 Getting geometry arrays:

 &#x60;&#x60;&#x60;&#x60;javascript
 ver geometry = mesh.geometry;

 var primitive = geometry.primitive;        // Default is &quot;triangles&quot;
 var positions = geometry.positions;        // Local-space vertex positions
 var normals = geometry.normals;            // Local-space vertex Normals
 var uv = geometry.uv;                      // UV coordinates
 var indices = mesh.geometry.indices;     // Vertex indices for pimitives
 &#x60;&#x60;&#x60;&#x60;

 The Mesh also has a convenience property which provides the vertex positions in World-space, ie. after they have been
 transformed by the Mesh&#x27;s {{#crossLink &quot;Object/worldMatrix:property&quot;}}{{/crossLink}}:

 &#x60;&#x60;&#x60;&#x60;javascript
 // These are internally generated on-demand and cached. To free the cached
 // vertex World positions when you&#x27;re done with them, set this property to null or undefined
 var worldPositions = mesh.worldPositions;
 &#x60;&#x60;&#x60;&#x60;

 ### Material

 A Mesh has a {{#crossLink &quot;Material&quot;}}{{/crossLink}}, which describes its appearance. When we don&#x27;t provide it with
 a Material, it will automatically get its {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s {{#crossLink &quot;Scene/material:property&quot;}}{{/crossLink}} by default.

 Creating a Mesh with its own custom {{#crossLink &quot;Geometry&quot;}}{{/crossLink}} and {{#crossLink &quot;MetallicMaterial&quot;}}{{/crossLink}}:

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
     geometry: new xeogl.TeapotGeometry(),
     material: new xeogl.MetallicMaterial({
         baseColor: [0.0, 0.0, 1.0],
         metallic: 1.0,
         roughness: 1.0,
         emissive: [0.0, 0.0, 0.0],
         alpha: 1.0
     })
 });
 &#x60;&#x60;&#x60;&#x60;

 Animating the {{#crossLink &quot;MetallicMaterial&quot;}}{{/crossLink}}&#x27;s diffuse color - making the Mesh rapidly pulse red:

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.scene.on(&quot;tick&quot;, function(e) {
    var t = e.time - e.startTime; // Millisecs
    mesh.material.baseColor = [0.5 + Math.sin(t * 0.01), 0.0, 0.0]; // RGB
 });
 &#x60;&#x60;&#x60;&#x60;

 ### Transforming

 A Mesh can be positioned within the World-space coordinate system.

 See {{#crossLink &quot;Object&quot;}}{{/crossLink}}.

 ### Ghosting

 Ghost a Mesh by setting its {{#crossLink &quot;Mesh/ghosted:property&quot;}}{{/crossLink}} property true. The Mesh&#x27;s
 {{#crossLink &quot;Mesh/ghostMaterial:property&quot;}}{{/crossLink}} property holds the {{#crossLink &quot;EmphasisMaterial&quot;}}{{/crossLink}}
 that controls its appearance while ghosted.

 When we don&#x27;t provide it with a EmphasisMaterial, the Mesh will automatically get its Scene&#x27;s {{#crossLink &quot;Scene/ghostMaterial:property&quot;}}{{/crossLink}}
 by default.

 In the example below, we&#x27;ll create a ghosted Mesh with its own EmphasisMaterial for ghosted appearance:

 &lt;a href=&quot;../../examples/#effects_ghost&quot;&gt;&lt;img src=&quot;../../assets/images/screenshots/EmphasisMaterial/teapot.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    ghostMaterial: new xeogl.EmphasisMaterial({
        edges: true,
        edgeColor: [0.2, 1.0, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 2,
        vertices: true,
        vertexColor: [0.6, 1.0, 0.6],
        vertexAlpha: 1.0,
        vertexSize: 8,
        fill: true,
        fillColor: [0, 0, 0],
        fillAlpha: 0.7
    }),
    ghosted: true
 });
 &#x60;&#x60;&#x60;&#x60;

 #### Examples

 * [Ghosted teapot](../../examples/#effects_demo_hoverToGhost)

 ### Highlighting

 Highlight a Mesh by setting its {{#crossLink &quot;Mesh/highlighted:property&quot;}}{{/crossLink}} property true. The Mesh&#x27;s
 {{#crossLink &quot;Mesh/highlightMaterial:property&quot;}}{{/crossLink}} property holds the {{#crossLink &quot;EmphasisMaterial&quot;}}{{/crossLink}}
 that controls its appearance while highlighted.

 When we don&#x27;t provide it with a EmphasisMaterial for highlighting, it will automatically get its Scene&#x27;s {{#crossLink &quot;Scene/highlightMaterial:property&quot;}}{{/crossLink}}
 by default.

 In the example below, we&#x27;ll create a highlighted Mesh with its own EmphasisMaterial for highlighted appearance:

 &lt;a href=&quot;../../examples/#effects_highlight&quot;&gt;&lt;img src=&quot;../../assets/images/screenshots/EmphasisMaterial/teapotHighlighted.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    highlightMaterial: new xeogl.EmphasisMaterial({
        color: [1.0, 1.0, 0.0],
        alpha: 0.6
    }),
    highlighted: true
 });
 &#x60;&#x60;&#x60;&#x60;

 #### Examples

 * [Ghost and highlight effects](../../examples/#effects_demo_hoverToHighlight)

 ### Selecting

 Make a Mesh appear selected by setting its {{#crossLink &quot;Mesh/selected:property&quot;}}{{/crossLink}} property true. The Mesh&#x27;s
 {{#crossLink &quot;Mesh/selectedMaterial:property&quot;}}{{/crossLink}} property holds the {{#crossLink &quot;EmphasisMaterial&quot;}}{{/crossLink}}
 that controls its appearance while selected.

 When we don&#x27;t provide it with a EmphasisMaterial for selecting, it will automatically get its Scene&#x27;s {{#crossLink &quot;Scene/selectMaterial:property&quot;}}{{/crossLink}}
 by default.

 In the example below, we&#x27;ll create a selected Mesh with its own EmphasisMaterial for selection appearance:

 &lt;a href=&quot;../../examples/#effects_select&quot;&gt;&lt;img src=&quot;../../assets/images/screenshots/EmphasisMaterial/teapotSelected.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    selectMaterial: new xeogl.EmphasisMaterial({
        color: [1.0, 1.0, 0.0],
        alpha: 0.6
    }),
    selected: true
 });
 &#x60;&#x60;&#x60;&#x60;

 #### Examples

 * [Ghost and select effects](../../examples/#effects_demo_gearbox)


 ### Edges

 Emphasise a Mesh&#x27;s edges by setting its {{#crossLink &quot;Mesh/edges:property&quot;}}{{/crossLink}} property true. The Mesh&#x27;s
 {{#crossLink &quot;Mesh/edgeMaterial:property&quot;}}{{/crossLink}} property holds the {{#crossLink &quot;EdgeMaterial&quot;}}{{/crossLink}}
 that controls the appearance of the edges while they are emphasized.

 When we don&#x27;t provide it with an EdgeMaterial, the Mesh will automatically get its Scene&#x27;s {{#crossLink &quot;Scene/edgeMaterial:property&quot;}}{{/crossLink}}
 by default.

 In the example below, we&#x27;ll create a edges Mesh with its own EdgeMaterial for edges appearance:

 &lt;a href=&quot;../../examples/#effects_ghost&quot;&gt;&lt;img src=&quot;../../assets/images/screenshots/EdgeMaterial/teapot.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    edgeMaterial: new xeogl.EdgeMaterial({
        edgeColor: [0.2, 1.0, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 2
    }),
    edges: true
 });
 &#x60;&#x60;&#x60;&#x60;

 ### Outlining

 Outline a Mesh by setting its {{#crossLink &quot;Mesh/outlined:property&quot;}}{{/crossLink}} property true. The Mesh&#x27;s
 {{#crossLink &quot;Mesh/outlineMaterial:property&quot;}}{{/crossLink}} property holds the {{#crossLink &quot;OutlineMaterial&quot;}}{{/crossLink}}
 that controls its appearance while outlined.

 When we don&#x27;t provide it with an {{#crossLink &quot;OutlineMaterial&quot;}}{{/crossLink}}, it will automatically get its Scene&#x27;s
 {{#crossLink &quot;Scene/outlineMaterial:property&quot;}}{{/crossLink}} by default.

 In the example below, we&#x27;ll create a outlined Mesh with its own {{#crossLink &quot;OutlineMaterial&quot;}}{{/crossLink}}:

 &lt;a href=&quot;../../examples/#effects_outline&quot;&gt;&lt;img src=&quot;../../assets/images/screenshots/OutlineMaterial/teapot.png&quot;&gt;&lt;/img&gt;&lt;/a&gt;

 &#x60;&#x60;&#x60;&#x60;javascript
 var mesh = new xeogl.Mesh({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    outlineMaterial: new xeogl.OutlineMaterial({
        color: [1.0, 1.0, 0.0],
        alpha: 0.6,
        width: 5
    }),
    outlined: true
 });
 &#x60;&#x60;&#x60;&#x60;

 ### Local-space boundary

 We can query a Mesh&#x27;s Local-space boundary at any time, getting it as either an axis-aligned bounding box (AABB) or
 an object-aligned bounding box (OBB).

 The Local-space AABB and OBB belong to the Mesh&#x27;s {{#crossLink &quot;Geometry&quot;}}{{/crossLink}}.

 Getting the Local-space AABB:

 &#x60;&#x60;&#x60;&#x60;
 var aabb = mesh.geometry.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 &#x60;&#x60;&#x60;&#x60;

 Getting the Local-space OBB:

 &#x60;&#x60;&#x60;&#x60; javascript
 var obb = mesh.geometry.obb; // Flat array containing eight 3D corner vertices of a box
 &#x60;&#x60;&#x60;&#x60;

 #### Examples

 * [Local-space Geometry AABB](../../examples/#boundaries_geometry_aabb)
 * [Local-space Geometry OBB](../../examples/#boundaries_geometry_obb)

 ### World-space boundary

 We can query a Mesh&#x27;s World-space boundary at any time, getting it as an axis-aligned bounding box (AABB).

 The World-space AABB is the boundary of the Mesh&#x27;s {{#crossLink &quot;Geometry&quot;}}{{/crossLink}} after transformation by the
 Mesh&#x27;s {{#crossLink &quot;Object/worldMatrix:property&quot;}}{{/crossLink}} and the {{#crossLink &quot;Camera&quot;}}{{/crossLink}}&#x27;s
 {{#crossLink &quot;Camera/matrix:property&quot;}}{{/crossLink}}.

 Getting the World-space boundary AABB:

 &#x60;&#x60;&#x60;&#x60;javascript
 var aabb = mesh.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 &#x60;&#x60;&#x60;&#x60;

 Subscribing to updates of the World-space boundary, which occur after each update to the
 Mesh&#x27;s {{#crossLink &quot;Object/worldMatrix:property&quot;}}{{/crossLink}} or the {{#crossLink &quot;Camera&quot;}}{{/crossLink}}:

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.on(&quot;boundary&quot;, function() {
     var aabb = mesh.aabb;
     var obb = mesh.obb;
 });
 &#x60;&#x60;&#x60;&#x60;

 The {{#crossLink &quot;Scene&quot;}}{{/crossLink}} also has a {{#crossLink &quot;Scene/getAABB:method&quot;}}Scene#getAABB(){{/crossLink}}, which returns
 the collective World-space AABBs of the {{#crossLink &quot;Object&quot;}}Objects{{/crossLink}} with the given IDs:

 &#x60;&#x60;&#x60;&#x60;JavaScript
 var scene = mesh.scene;

 scene.getAABB(); // Gets collective boundary of all meshes in the scene
 scene.getAABB(&quot;saw&quot;); // Gets collective boundary of all meshes in a model
 scene.getAABB([&quot;saw&quot;, &quot;gearbox&quot;]); // Gets collective boundary of all meshes in two models
 scene.getAABB(&quot;saw#0.1&quot;); // Get boundary of a mesh
 scene.getAABB([&quot;saw#0.1&quot;, &quot;saw#0.2&quot;]); // Get collective boundary of two meshes
 &#x60;&#x60;&#x60;&#x60;

 #### Excluding from boundary calculations

 The {{#crossLink &quot;Scene/aabb:property&quot;}}Scene aabb{{/crossLink}}
 and parent {{#crossLink &quot;Object/aabb:property&quot;}}Object{{/crossLink}}&#x27;s {{#crossLink &quot;Object/aabb:property&quot;}}aabb{{/crossLink}}
 properties provide AABBs that dynamically include the AABB of all contained Meshes, except those Meshes that have
 their {{#crossLink &quot;Mesh/collidable:property&quot;}}collidable{{/crossLink}} properties set &#x60;&#x60;&#x60;&#x60;false&#x60;&#x60;&#x60;&#x60;.

 Toggle that inclusion like so:

 &#x60;&#x60;&#x60;&#x60;javascript
 mesh.collidable = false; // Exclude mesh from calculation of its Scene/Model boundary
 mesh.collidable = true; // Include mesh in calculation of its Scene/Model boundary
 &#x60;&#x60;&#x60;&#x60;
 Setting this false is useful when a Mesh represents some element, such as a control gizmo, that you don&#x27;t want to
 contribute to the  {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} or parent {{#crossLink &quot;Object&quot;}}{{/crossLink}}&#x27;s AABB. It
 also helps performance, since boundaries will not need dynamically re-calculated whenever the Mesh&#x27;s boundary changes after
 a {{#crossLink &quot;Object/worldMatrix:property&quot;}}{{/crossLink}} or {{#crossLink &quot;Camera&quot;}}{{/crossLink}} update.

 #### Examples

 * [World-space Mesh AABB](../../examples/#boundaries_mesh_aabb)
 * [World-space Mesh OBB](../../examples/#boundaries_mesh_obb)

 ### Skyboxing

 A Mesh has a {{#crossLink &quot;Mesh/stationary:property&quot;}}{{/crossLink}} property
 that will cause it to never translate with respect to the viewpoint.

 This is useful for using Meshes as skyboxes, like this:

 &#x60;&#x60;&#x60;&#x60;javascript
 new xeogl.Mesh({

     geometry: new xeogl.BoxGeometry({
         xSize: 1000,
         ySize: 1000,
         zSize: 1000
     }),

     material: new xeogl.PhongMaterial({
         diffuseMap: new xeogl.Texture({
            src: &quot;textures/diffuse/uvGrid2.jpg&quot;
         })
     }),

     stationary: true // Locks position with respect to viewpoint
 });
 &#x60;&#x60;&#x60;&#x60;

 #### Examples

 * [Skybox component](../../examples/#skyboxes_skybox)
 * [Custom skybox](../../examples/#skyboxes_skybox_custom)

 ### Billboarding

 A Mesh has a {{#crossLink &quot;Mesh/billboard:property&quot;}}{{/crossLink}} property
 that can make it behave as a billboard.

 Two billboard types are supported:

 * **Spherical** billboards are free to rotate their Meshes in any direction and always face the {{#crossLink &quot;Camera&quot;}}{{/crossLink}} perfectly.
 * **Cylindrical** billboards rotate their Meshes towards the {{#crossLink &quot;Camera&quot;}}{{/crossLink}}, but only about the Y-axis.

 Note that scaling transformations to have no effect on billboarded Meshes.

 The example below shows a box that remains rotated directly towards the viewpoint, using spherical billboarding:

 &#x60;&#x60;&#x60;&#x60;javascript
 new xeogl.Mesh({

     geometry: new xeogl.BoxGeometry(),

     material: new xeogl.PhongMaterial({
         diffuseMap: new xeogl.Texture({
            src: &quot;textures/diffuse/uvGrid2.jpg&quot;
         })
     }),

     billboard: &quot;spherical&quot; // Or &quot;cylindrical&quot;
 });
 &#x60;&#x60;&#x60;&#x60;

 #### Examples

 * [Spherical billboards](../../examples/#billboards_spherical)
 * [Cylindrical billboards](../../examples/#billboards_cylindrical)
 * [Clouds using billboards](../../examples/#billboards_spherical_clouds)


 ### Shadows

 [Work-in-progress]

 @class Mesh
 @module xeogl
 @submodule objects
 @constructor
 @param [owner] {Component} Owner component. When destroyed, the owner will destroy this component as well. Creates this component within the default {{#crossLink &quot;Scene&quot;}}{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Mesh.
 @param [cfg.entityType] {String} Optional entity classification when using within a semantic data model. See the {{#crossLink &quot;Object&quot;}}{{/crossLink}} documentation for usage.
 @param [cfg.parent] {Object} The parent.
 @param [cfg.position=[0,0,0]] {Float32Array} The Mesh&#x27;s local 3D position.
 @param [cfg.scale=[1,1,1]] {Float32Array} The Mesh&#x27;s local scale.
 @param [cfg.rotation=[0,0,0]] {Float32Array} The Mesh&#x27;s local rotation, as Euler angles given in degrees, for each of the X, Y and Z axis.
 @param [cfg.matrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1] {Float32Array} The Mesh&#x27;s local modelling transform matrix. Overrides the position, scale and rotation parameters.

 @param [cfg.geometry] {Geometry} Defines shape. Must be within the same {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} as this Mesh. Defaults to the
 parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s default instance, {{#crossLink &quot;Scene/geometry:property&quot;}}geometry{{/crossLink}}, which is a 2x2x2 box.
 @param [cfg.material] {Material} Defines normal rendered appearance. Must be within the same {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} as this Mesh. Defaults to the
 parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s default instance, {{#crossLink &quot;Scene/material:property&quot;}}material{{/crossLink}}.
 @param [cfg.outlineMaterial] {OutlineMaterial} Defines appearance when outlined. Must be within the same {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} as this Mesh. Defaults to the
 parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s default instance, {{#crossLink &quot;Scene/outlineMaterial:property&quot;}}outlineMaterial{{/crossLink}}.
 @param [cfg.ghostMaterial] Defines appearance when ghosted. Must be within the same {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} as this Mesh. Defaults to the
 parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s default instance, {{#crossLink &quot;Scene/ghostMaterial:property&quot;}}ghostMaterial{{/crossLink}}.
 @param [cfg.highlightMaterial] Defines appearance when highlighted. Must be within the same {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} as this Mesh. Defaults to the
 parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s default instance, {{#crossLink &quot;Scene/highlightMaterial:property&quot;}}highlightMaterial{{/crossLink}}.
 @param [cfg.selectedMaterial] Defines appearance when selected. Must be within the same {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} as this Mesh. Defaults to the
 parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s default instance, {{#crossLink &quot;Scene/selectedMaterial:property&quot;}}selectedMaterial{{/crossLink}}.
 @param [cfg.colorize=[1.0,1.0,1.0]] {Float32Array} RGB colorize color, multiplies by the rendered fragment colors.
 @param [cfg.opacity=1.0] {Number} Opacity factor, multiplies by the rendered fragment alpha.
 @param [cfg.layer=0] {Number} Indicates this Mesh&#x27;s rendering priority, relative to other Meshes. Typically used for transparency sorting,
 @param [cfg.stationary=false] {Boolean} Disables the effect of {{#crossLink &quot;Camera&quot;}}{{/crossLink}} translations for this Mesh. This is useful for making skyboxes.
 @param [cfg.billboard=&quot;none&quot;] {String} Specifies the billboarding behaviour for this Mesh. Options are &quot;none&quot;, &quot;spherical&quot; and &quot;cylindrical&quot;.

 @param [cfg.visible=true] {Boolean}        Indicates if this Mesh is visible. Mesh is only rendered when visible and not culled.
 @param [cfg.culled=false] {Boolean}        Indicates if this Mesh is culled from view. Mesh is only rendered when visible and not culled.
 @param [cfg.pickable=true] {Boolean}       Indicates if this Mesh is pickable. When false, the Mesh will never be picked by calls to the {{#crossLink &quot;Scene/pick:method&quot;}}Scene pick(){{/crossLink}} method, and picking will happen as &quot;through&quot; the Mesh, to attempt to pick whatever lies on the other side of it.
 @param [cfg.clippable=true] {Boolean}      Indicates if this Mesh is clippable by {{#crossLink &quot;Clips&quot;}}{{/crossLink}}. When false, Mesh will not be affected by the {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s {{#crossLink &quot;Clips&quot;}}{{/crossLink}}.
 @param [cfg.collidable=true] {Boolean}     Whether this Mesh is included in boundary calculations. When false, the bounding boxes of the containing {{#crossLink &quot;Scene&quot;}}{{/crossLink}} and parent {{#crossLink &quot;Object&quot;}}{{/crossLink}}, {{#crossLink &quot;Group&quot;}}{{/crossLink}} or {{#crossLink &quot;Model&quot;}}{{/crossLink}} will not be calculated to enclose this Mesh.
 @param [cfg.castShadow=true] {Boolean}     Whether this Mesh casts shadows.
 @param [cfg.receiveShadow=true] {Boolean}  Whether this Mesh receives shadows.
 @param [cfg.outlined=false] {Boolean}      Whether an outline is rendered around this mesh.
 @param [cfg.ghosted=false] {Boolean}       Whether this Mesh is rendered with a ghosted appearance.
 @param [cfg.highlighted=false] {Boolean}   Whether this Mesh is rendered with a highlighted appearance.
 @param [cfg.selected=false] {Boolean}      Whether this Mesh is rendered with a selected appearance.
 @param [cfg.aabbVisible=false] {Boolean}   Whether this Mesh&#x27;s World-space axis-aligned bounding box (AABB) is visible.
 @param [cfg.obbVisible=false] {Boolean}    Whether this Mesh&#x27;s World-space oriented bounding box (OBB) is visible.

 @param [cfg.colorize=[1.0,1.0,1.0]] {Float32Array}  RGB colorize color, multiplies by the rendered fragment colors.
 @param [cfg.opacity=1.0] {Number} Opacity factor, multiplies by the rendered fragment alpha.

 @param [cfg.loading=false] {Boolean} Flag which indicates that this Mesh is freshly loaded.

 @extends Object
 */

/**
 Fired when this Mesh is picked via a call to {{#crossLink &quot;Scene/pick:method&quot;}}Scene#pick(){{/crossLink}}.

 The event parameters will be the hit result returned by the {{#crossLink &quot;Scene/pick:method&quot;}}Scene#pick(){{/crossLink}} method.
 @event picked
 */
import {math} from &#x27;../math/math.js&#x27;;
import {xeoglObject} from &#x27;./object.js&#x27;;
import {State} from &#x27;../renderer/state.js&#x27;;
import {DrawRenderer} from &quot;../renderer/draw/drawRenderer.js&quot;;
import {EmphasisFillRenderer} from &quot;../renderer/emphasis/emphasisFillRenderer.js&quot;;
import {EmphasisEdgesRenderer} from &quot;../renderer/emphasis/emphasisEdgesRenderer.js&quot;;
import {EmphasisVerticesRenderer} from &quot;../renderer/emphasis/emphasisVerticesRenderer.js&quot;;
import {ShadowRenderer} from &quot;../renderer/shadow/shadowRenderer.js&quot;;
import {OutlineRenderer} from &quot;../renderer/outline/outlineRenderer.js&quot;;
import {PickMeshRenderer} from &quot;../renderer/pick/pickMeshRenderer.js&quot;;
import {PickVertexRenderer} from &quot;../renderer/pick/pickVertexRenderer.js&quot;;
import {PickTriangleRenderer} from &quot;../renderer/pick/pickTriangleRenderer.js&quot;;
import {componentClasses} from &quot;./../componentClasses.js&quot;;

const obb = math.OBB3();

const type = &quot;xeogl.Mesh&quot;;

class Mesh extends xeoglObject {

    /**
     JavaScript class name for this Component.

     For example: &quot;xeogl.AmbientLight&quot;, &quot;xeogl.MetallicMaterial&quot; etc.

     @property type
     @type String
     @final
     */
    get type() {
        return type;
    }

    static _compareState(a, b) {
        return (a._state.layer - b._state.layer)
            || (a._drawRenderer.id - b._drawRenderer.id) // Program state
            || (a._material._state.id - b._material._state.id) // Material state
            || (a._vertexBufs.id - b._vertexBufs.id)  // SHared vertex bufs
            || (a._geometry._state.id - b._geometry._state.id); // Geometry state
    }

    init(cfg) {

        this._state = new State({ // NOTE: Renderer gets modeling and normal matrices from xeogl.Object#matrix and xeogl.Object.#normalMatrix
            visible: true,
            culled: false,
            pickable: null,
            clippable: null,
            colorize: null,
            collidable: null,
            castShadow: null,
            receiveShadow: null,
            outlined: null,
            ghosted: false,
            highlighted: false,
            selected: false,
            edges: false,
            layer: null,
            billboard: this._checkBillboard(cfg.billboard),
            stationary: !!cfg.stationary,
            hash: &quot;&quot;
        });

        this._drawRenderer = null;
        this._shadowRenderer = null;
        this._emphasisFillRenderer = null;
        this._emphasisEdgesRenderer = null;
        this._emphasisVerticesRenderer = null;
        this._pickMeshRenderer = null;
        this._pickTriangleRenderer = null;

        this._worldPositions = null;
        this._worldPositionsDirty = true;
        this._geometry = cfg.geometry ? this._checkComponent(&quot;xeogl.Geometry&quot;, cfg.geometry) : this.scene.geometry;
        this._vertexBufs = this._geometry._getVertexBufs();
        this._material = cfg.material ? this._checkComponent(&quot;xeogl.Material&quot;, cfg.material) : this.scene.material;
        this._ghostMaterial = cfg.ghostMaterial ? this._checkComponent(&quot;xeogl.EmphasisMaterial&quot;, cfg.ghostMaterial) : this.scene.ghostMaterial;
        this._outlineMaterial = cfg.outlineMaterial ? this._checkComponent(&quot;xeogl.EmphasisMaterial&quot;, cfg.outlineMaterial) : this.scene.outlineMaterial;
        this._highlightMaterial = cfg.highlightMaterial ? this._checkComponent(&quot;xeogl.EmphasisMaterial&quot;, cfg.highlightMaterial) : this.scene.highlightMaterial;
        this._selectedMaterial = cfg.selectedMaterial ? this._checkComponent(&quot;xeogl.EmphasisMaterial&quot;, cfg.selectedMaterial) : this.scene.selectedMaterial;
        this._edgeMaterial = cfg.edgeMaterial ? this._checkComponent(&quot;xeogl.EdgeMaterial&quot;, cfg.edgeMaterial) : this.scene.edgeMaterial;

        this._compile();

        super.init(cfg); // Call xeogl.Object._init()

        this.scene._meshCreated(this);
    }

    _checkBillboard(value) {
        value = value || &quot;none&quot;;
        if (value !== &quot;spherical&quot; &amp;&amp; value !== &quot;cylindrical&quot; &amp;&amp; value !== &quot;none&quot;) {
            this.error(&quot;Unsupported value for &#x27;billboard&#x27;: &quot; + value + &quot; - accepted values are &quot; +
                &quot;&#x27;spherical&#x27;, &#x27;cylindrical&#x27; and &#x27;none&#x27; - defaulting to &#x27;none&#x27;.&quot;);
            value = &quot;none&quot;;
        }
        return value;
    }

    _compile() {
        this._putRenderers();
        this._makeHash();
        this._drawRenderer = DrawRenderer.get(this);
        this._shadowRenderer = ShadowRenderer.get(this);
        this._emphasisFillRenderer = EmphasisFillRenderer.get(this);
        this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this);
        this._emphasisVerticesRenderer = EmphasisVerticesRenderer.get(this);
        this._pickMeshRenderer = PickMeshRenderer.get(this);

        this._renderer.meshListDirty();
    }

    _webglContextRestored() {
        if (this._drawRenderer) {
            this._drawRenderer.webglContextRestored();
        }
        if (this._shadowRenderer) {
            this._shadowRenderer.webglContextRestored();
        }
        if (this._emphasisFillRenderer) {
            this._emphasisFillRenderer.webglContextRestored();
        }
        if (this._emphasisEdgesRenderer) {
            this._emphasisEdgesRenderer.webglContextRestored();
        }
        if (this._emphasisVerticesRenderer) {
            this._emphasisVerticesRenderer.webglContextRestored();
        }
        if (this._pickMeshRenderer) {
            this._pickMeshRenderer.webglContextRestored();
        }
        if (this._pickTriangleRenderer) {
            this._pickMeshRenderer.webglContextRestored();
        }
    }

    _makeHash() {
        const hash = [];
        const state = this._state;
        if (state.stationary) {
            hash.push(&quot;/s&quot;);
        }
        if (state.billboard === &quot;none&quot;) {
            hash.push(&quot;/n&quot;);
        } else if (state.billboard === &quot;spherical&quot;) {
            hash.push(&quot;/s&quot;);
        } else if (state.billboard === &quot;cylindrical&quot;) {
            hash.push(&quot;/c&quot;);
        }
        if (state.receiveShadow) {
            hash.push(&quot;/rs&quot;);
        }
        hash.push(&quot;;&quot;);
        this._state.hash = hash.join(&quot;&quot;);
    }

    _buildMeshAABB(worldMatrix, aabb) { // TODO: factor out into class member
        math.transformOBB3(worldMatrix, this._geometry.obb, obb);
        math.OBB3ToAABB3(obb, aabb);
    }

    _getSceneHash() {
        return (this.scene.gammaInput ? &quot;gi;&quot; : &quot;;&quot;) + (this.scene.gammaOutput ? &quot;go&quot; : &quot;&quot;);
    }

    //--------------------- Rendering ------------------------------------------------------------------------------

    _draw(frame) {
        if (this._drawRenderer || (this._drawRenderer = DrawRenderer.get(this))) {
            this._drawRenderer.drawMesh(frame, this);
        }
    }

    _drawGhostFill(frame) {
        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) {
            this._emphasisFillRenderer.drawMesh(frame, this, 0); // 0 == ghost
        }
    }

    _drawGhostEdges(frame) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frame, this, 0); // 0 == ghost
        }
    }

    _drawGhostVertices(frame) {
        if (this._emphasisVerticesRenderer || (this._emphasisVerticesRenderer = EmphasisVerticesRenderer.get(this))) {
            this._emphasisVerticesRenderer.drawMesh(frame, this, 0); // 0 == ghost
        }
    }

    _drawHighlightFill(frame) {
        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) {
            this._emphasisFillRenderer.drawMesh(frame, this, 1); // 1 == highlight
        }
    }

    _drawHighlightEdges(frame) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frame, this, 1); // 1 == highlight
        }
    }

    _drawHighlightVertices(frame) {
        if (this._emphasisVerticesRenderer || (this._emphasisVerticesRenderer = EmphasisVerticesRenderer.get(this))) {
            this._emphasisVerticesRenderer.drawMesh(frame, this, 1); // 1 == highlight
        }
    }

    _drawSelectedFill(frame) {
        if (this._emphasisFillRenderer || (this._emphasisFillRenderer = EmphasisFillRenderer.get(this))) {
            this._emphasisFillRenderer.drawMesh(frame, this, 2); // 2 == selected
        }
    }

    _drawSelectedEdges(frame) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frame, this, 2); // 2 == selected
        }
    }

    _drawSelectedVertices(frame) {
        if (this._emphasisVerticesRenderer || (this._emphasisVerticesRenderer = EmphasisVerticesRenderer.get(this))) {
            this._emphasisVerticesRenderer.drawMesh(frame, this, 2); // 2 == selected
        }
    }

    _drawEdges(frame) {
        if (this._emphasisEdgesRenderer || (this._emphasisEdgesRenderer = EmphasisEdgesRenderer.get(this))) {
            this._emphasisEdgesRenderer.drawMesh(frame, this, 3); // 3 == edges
        }
    }

    _drawShadow(frame, light) {
        if (this._shadowRenderer || (this._shadowRenderer = ShadowRenderer.get(this))) {
            this._shadowRenderer.drawMesh(frame, this, light);
        }
    }

    _drawOutline(frame) {
        if (this._shadowRenderer || (this._outlineRenderer = OutlineRenderer.get(this))) {
            this._outlineRenderer.drawMesh(frame, this);
        }
    }

    _pickMesh(frame) {
        if (this._pickMeshRenderer || (this._pickMeshRenderer = PickMeshRenderer.get(this))) {
            this._pickMeshRenderer.drawMesh(frame, this);
        }
    }

    _pickTriangle(frame) {
        if (this._pickTriangleRenderer || (this._pickTriangleRenderer = PickTriangleRenderer.get(this))) {
            this._pickTriangleRenderer.drawMesh(frame, this);
        }
    }

    _pickVertex(frame) {
        if (this._pickVertexRenderer || (this._pickVertexRenderer = PickVertexRenderer.get(this))) {
            this._pickVertexRenderer.drawMesh(frame, this);
        }
    }

    _getOutlineRenderer() {
        this._outlineRenderer = OutlineRenderer.get(this);
        if (this._outlineRenderer.errors) {
            this.errors = (this.errors || []).concat(this._outlineRenderer.errors);
            this.error(this._outlineRenderer.errors.join(&quot;\n&quot;));
            return false;
        }
        return true;
    }

    _putRenderers() {
        if (this._drawRenderer) {
            this._drawRenderer.put();
            this._drawRenderer = null;
        }
        if (this._shadowRenderer) {
            this._shadowRenderer.put();
            this._shadowRenderer = null;
        }
        if (this._emphasisFillRenderer) {
            this._emphasisFillRenderer.put();
            this._emphasisFillRenderer = null;
        }
        if (this._emphasisEdgesRenderer) {
            this._emphasisEdgesRenderer.put();
            this._emphasisEdgesRenderer = null;
        }
        if (this._emphasisVerticesRenderer) {
            this._emphasisVerticesRenderer.put();
            this._emphasisVerticesRenderer = null;
        }
        if (this._outlineRenderer) {
            this._outlineRenderer.put();
            this._outlineRenderer = null;
        }
        if (this._pickMeshRenderer) {
            this._pickMeshRenderer.put();
            this._pickMeshRenderer = null;
        }
        if (this._pickTriangleRenderer) {
            this._pickTriangleRenderer.put();
            this._pickTriangleRenderer = null;
        }
        if (this._pickVertexRenderer) {
            this._pickVertexRenderer.put();
            this._pickVertexRenderer = null;
        }
    }

    /**
     World-space 3D vertex positions.

     These are internally generated on-demand and cached. To free the cached
     vertex World positions when you&#x27;re done with them, set this property to null or undefined.

     @property worldPositions
     @type Float32Array
     @final
     */
    get worldPositions() {
        if (this._worldPositionsDirty) {
            const positions = this._geometry.positions;
            if (!this._worldPositions) {
                this._worldPositions = new Float32Array(positions.length);
            }
            math.transformPositions3(this.worldMatrix, positions, this._worldPositions);
            this._worldPositionsDirty = false;
        }
        return this._worldPositions;
    }

    set worldPositions(value) {
        if (value = undefined || value === null) {
            this._worldPositions = null; // Release memory
            this._worldPositionsDirty = true;
        }
    }

    /**
     Defines the shape of this Mesh.

     @property geometry
     @type Geometry
     @final
     */
    get geometry() {
        return this._geometry;
    }

    /**
     Defines appearance when rendering normally, ie. when not ghosted, highlighted or selected.

     @property material
     @type Material
     @final
     */
    get material() {
        return this._material;
    }

    /**
     Defines surface appearance when ghosted.

     @property ghostMaterial
     @type EmphasisMaterial
     @final
     */
    get ghostMaterial() {
        return this._ghostMaterial;
    }

    /**
     Defines surface appearance when highlighted.

     @property highlightMaterial
     @type EmphasisMaterial
     @final
     */
    get highlightMaterial() {
        return this._highlightMaterial;
    }

    /**
     Defines surface appearance when selected.

     @property selectedMaterial
     @type EmphasisMaterial
     */
    get selectedMaterial() {
        return this._selectedMaterial;
    }

    /**
     Defines surface appearance when edges are shown.

     @property edgeMaterial
     @type EdgeMaterial
     */
    get edgeMaterial() {
        return this._edgeMaterial;
    }

    /**
     Defines surface appearance when outlined.

     @property outlineMaterial
     @type OutlineMaterial
     */
    get outlineMaterial() {
        return this._outlineMaterial;
    }

    /**
     Indicates if visible.

     The Mesh is only rendered when {{#crossLink &quot;Mesh/visible:property&quot;}}{{/crossLink}} is true and
     {{#crossLink &quot;Mesh/culled:property&quot;}}{{/crossLink}} is false.

     Each visible Mesh is registered in the {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s
     {{#crossLink &quot;Scene/visibleEntities:property&quot;}}{{/crossLink}} map when its {{#crossLink &quot;Object/entityType:property&quot;}}{{/crossLink}}
     is set to a value.

     @property visible
     @default true
     @type Boolean
     */
    set visible(visible) {
        visible = visible !== false;
        this._state.visible = visible;
        if (this._entityType) {
            this.scene._entityVisibilityUpdated(this, visible);
        }
        this._renderer.imageDirty();
        if (this._state.castShadow) {
            this._renderer.shadowsDirty();
        }
    }

    get visible() {
        return this._state.visible;
    }

    /**
     Indicates if ghosted.

     The ghosted appearance is configured by {{#crossLink &quot;Mesh/ghostMaterial:property&quot;}}ghostMaterial{{/crossLink}}.

     Each ghosted Mesh is registered in its {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s
     {{#crossLink &quot;Scene/ghostedEntities:property&quot;}}{{/crossLink}} map when its {{#crossLink &quot;Object/entityType:property&quot;}}{{/crossLink}}
     is set to a value.

     @property ghosted
     @default false
     @type Boolean
     */
    set ghosted(ghosted) {
        ghosted = !!ghosted;
        if (this._state.ghosted === ghosted) {
            return;
        }
        this._state.ghosted = ghosted;
        if (this._entityType) {
            this.scene._entityGhostedUpdated(this, ghosted);
        }
        this._renderer.imageDirty();
    }

    get ghosted() {
        return this._state.ghosted;
    }

    /**
     Indicates if highlighted.

     The highlight appearance is configured by {{#crossLink &quot;Mesh/highlightMaterial:property&quot;}}highlightMaterial{{/crossLink}}.

     Each highlighted Mesh is registered in its {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s
     {{#crossLink &quot;Scene/highlightedEntities:property&quot;}}{{/crossLink}} map when its {{#crossLink &quot;Object/entityType:property&quot;}}{{/crossLink}}
     is set to a value.

     @property highlighted
     @default false
     @type Boolean
     */
    set highlighted(highlighted) {
        highlighted = !!highlighted;
        if (highlighted === this._state.highlighted) {
            return;
        }
        this._state.highlighted = highlighted;
        if (this._entityType) {
            this.scene._entityHighlightedUpdated(this, highlighted);
        }
        this._renderer.imageDirty();
    }

    get highlighted() {
        return this._state.highlighted;
    }

    /**
     Indicates if selected.

     The selected appearance is configured by {{#crossLink &quot;Mesh/selectedMaterial:property&quot;}}selectedMaterial{{/crossLink}}.

     Each selected Mesh is registered in its {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s
     {{#crossLink &quot;Scene/selectedEntities:property&quot;}}{{/crossLink}} map when its {{#crossLink &quot;Object/entityType:property&quot;}}{{/crossLink}}
     is set to a value.

     @property selected
     @default false
     @type Boolean
     */
    set selected(selected) {
        selected = !!selected;
        if (selected === this._state.selected) {
            return;
        }
        this._state.selected = selected;
        if (this._entityType) {
            this.scene._entitySelectedUpdated(this, selected);
        }
        this._renderer.imageDirty();
    }

    get selected() {
        return this._state.selected;
    }

    /**
     Indicates if edges are shown.

     The edges appearance is configured by {{#crossLink &quot;Mesh/edgeMaterial:property&quot;}}edgeMaterial{{/crossLink}}.

     @property edges
     @default false
     @type Boolean
     */
    set edges(edges) {
        edges = !!edges;
        if (edges === this._state.edges) {
            return;
        }
        this._state.edges = edges;
        this._renderer.imageDirty();
    }

    get edges() {
        return this._state.edges;
    }

    /**
     Indicates if culled from view.

     The MEsh is only rendered when {{#crossLink &quot;Mesh/visible:property&quot;}}{{/crossLink}} is true and
     {{#crossLink &quot;Mesh/culled:property&quot;}}{{/crossLink}} is false.

     @property culled
     @default false
     @type Boolean
     */
    set culled(value) {
        this._state.culled = !!value;
        this._renderer.imageDirty();
    }

    get culled() {
        return this._state.culled;
    }

    /**
     Indicates if pickable.

     When false, the Mesh will never be picked by calls to the {{#crossLink &quot;Scene/pick:method&quot;}}Scene pick(){{/crossLink}} method, and picking will happen as &quot;through&quot; the Mesh, to attempt to pick whatever lies on the other side of it.

     @property pickable
     @default true
     @type Boolean
     */
    set pickable(value) {
        value = value !== false;
        if (this._state.pickable === value) {
            return;
        }
        this._state.pickable = value;
        // No need to trigger a render;
        // state is only used when picking
    }

    get pickable() {
        return this._state.pickable;
    }

    /**
     Indicates if clippable.

     When false, the {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s {{#crossLink &quot;Clips&quot;}}{{/crossLink}} will have no effect on the Mesh.

     @property clippable
     @default true
     @type Boolean
     */
    set clippable(value) {
        value = value !== false;
        if (this._state.clippable === value) {
            return;
        }
        this._state.clippable = value;
        this._renderer.imageDirty();
        if (this._state.castShadow) {
            this._renderer.shadowsDirty();
        }
    }

    get clippable() {
        return this._state.clippable;
    }

    /**
     Indicates if included in boundary calculations.

     When false, this Mesh will not be included in the bounding boxes provided by parent components (

     @property collidable
     @default true
     @type Boolean
     */
    set collidable(value) {
        value = value !== false;
        if (value === this._state.collidable) {
            return;
        }
        this._state.collidable = value;
    }

    get collidable() {
        return this._state.collidable;
    }

    /**
     Indicates if casting shadows.

     @property castShadow
     @default true
     @type Boolean
     */
    set castShadow(value) {
        value = value !== false;
        if (value === this._state.castShadow) {
            return;
        }
        this._state.castShadow = value;
        this._renderer.shadowsDirty();
    }

    get castShadow() {
        return this._state.castShadow;
    }

    /**
     Indicates if receiving shadows.

     @property receiveShadow
     @default true
     @type Boolean
     */
    set receiveShadow(value) {
        this._state.receiveShadow = false; // Disables shadows for now
        // value = value !== false;
        // if (value === this._state.receiveShadow) {
        //     return;
        // }
        // this._state.receiveShadow = value;
        // this._state.hash = value ? &quot;/mod/rs;&quot; : &quot;/mod;&quot;;
        // this.fire(&quot;dirty&quot;, this); // Now need to (re)compile objectRenderers to include/exclude shadow mapping
    }

    get receiveShadow() {
        return this._state.receiveShadow;
    }

    /**
     Indicates if rendered with an outline.

     The outline appearance is configured by {{#crossLink &quot;Mesh/outlineMaterial:property&quot;}}outlineMaterial{{/crossLink}}.

     @property outlined
     @default false
     @type Boolean
     */
    set outlined(value) {
        value = !!value;
        if (value === this._state.outlined) {
            return;
        }
        this._state.outlined = value;
        this._renderer.imageDirty();
    }

    get outlined() {
        return this._state.outlined;
    }

    /**
     RGB colorize color, multiplies by the rendered fragment colors.

     @property colorize
     @default [1.0, 1.0, 1.0]
     @type Float32Array
     */
    set colorize(value) {
        let colorize = this._state.colorize;
        if (!colorize) {
            colorize = this._state.colorize = new Float32Array(4);
            colorize[3] = 1;
        }
        if (value) {
            colorize[0] = value[0];
            colorize[1] = value[1];
            colorize[2] = value[2];
        } else {
            colorize[0] = 1;
            colorize[1] = 1;
            colorize[2] = 1;
        }
        this._renderer.imageDirty();
    }

    get colorize() {
        return this._state.colorize;
    }

    /**
     Opacity factor, multiplies by the rendered fragment alpha.

     This is a factor in range &#x60;&#x60;&#x60;&#x60;[0..1]&#x60;&#x60;&#x60;&#x60;.

     @property opacity
     @default 1.0
     @type Number
     */
    set opacity(opacity) {
        let colorize = this._state.colorize;
        if (!colorize) {
            colorize = this._state.colorize = new Float32Array(4);
            colorize[0] = 1;
            colorize[1] = 1;
            colorize[2] = 1;
        }
        colorize[3] = opacity !== null &amp;&amp; opacity !== undefined ? opacity : 1.0;
        this._renderer.imageDirty();
    }

    get opacity() {
        return this._state.colorize[3];
    }

    /**
     The rendering order.

     This can be set on multiple transparent Meshes, to make them render in a specific order
     for correct alpha blending.

     @property layer
     @default 0
     @type Number
     */
    set layer(value) {
        // TODO: Only accept rendering layer in range [0...MAX_layer]
        value = value || 0;
        value = Math.round(value);
        if (value === this._state.layer) {
            return;
        }
        this._state.layer = value;
        this._renderer.needStateSort();
    }

    get layer() {
        return this._state.layer;
    }

    /**
     Indicates if the position is stationary.

     When true, will disable the effect of {{#crossLink &quot;Lookat&quot;}}view transform{{/crossLink}}
     translations for this Mesh, while still allowing it to rotate. This is useful for skybox Meshes.

     @property stationary
     @default false
     @type Boolean
     @final
     */
    get stationary() {
        return this._state.stationary;
    }

    /**
     Indicates the billboarding behaviour.

     Options are:

     * **&quot;none&quot;** -  **(default)** - No billboarding.
     * **&quot;spherical&quot;** - Mesh is billboarded to face the viewpoint, rotating both vertically and horizontally.
     * **&quot;cylindrical&quot;** - Mesh is billboarded to face the viewpoint, rotating only about its vertically
     axis. Use this mode for things like trees on a landscape.

     @property billboard
     @default &quot;none&quot;
     @type String
     @final
     */
    get billboard() {
        return this._state.billboard;
    }

    destroy() {
        super.destroy(); // xeogl.Object
        this._putRenderers();
        this._renderer.meshListDirty();
        this.scene._meshDestroyed(this);
        if (this._state.castShadow) {
            this._renderer.shadowsDirty();
        }
    }
}

componentClasses[type] = Mesh;

export {Mesh};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
